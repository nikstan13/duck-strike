<!DOCTYPE html>
<html lang="el">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    <meta name="description" content="Î Î±Î¯Î¾Îµ soccer pool Î¼Îµ Ï€Î±Ï€Î¬ÎºÎ¹Î±! Player vs Bot">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    
    <!-- Apple Touch Icons -->
    <link rel="apple-touch-icon" href="./icon-192.png">
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    
    <title>Duck Strike - Soccer Pool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            min-height: 100svh; /* Small viewport height - excludes browser UI */
            background: #000000; /* ÎœÎ±ÏÏÎ¿ background */
            font-family: Arial, sans-serif;
            overflow: hidden;
            margin: 0;
            padding: 0;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            height: 100svh;
            touch-action: none;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000000; /* ÎœÎ±ÏÏÎ¿ background */
            z-index: -1;
        }
        
        /* Floating ducks animation */
        .floating-duck {
            position: fixed;
            width: 60px;
            height: 60px;
            pointer-events: none;
            opacity: 0.15;
            z-index: 0;
            animation: float 20s infinite ease-in-out;
        }
        
        @keyframes float {
            0%, 100% {
                transform: translateY(0px) rotate(0deg);
            }
            25% {
                transform: translateY(-30px) rotate(90deg);
            }
            50% {
                transform: translateY(0px) rotate(180deg);
            }
            75% {
                transform: translateY(30px) rotate(270deg);
            }
        }
        
        /* ÎšÏÏÏˆÎµ Î¼ÏŒÎ½Î¿ Ï„Î± .controls (Î¿Î´Î·Î³Î¯ÎµÏ‚) */
        .controls {
            display: none !important;
        }
        
        /* Install banner Î³Î¹Î± ÎºÎ¹Î½Î·Ï„Î¬ */
        #installBanner {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 15px;
            text-align: center;
            z-index: 10000;
            border-top: 3px solid #FFD700;
            animation: slideUp 0.5s ease;
        }

        #installBanner.show {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        @keyframes slideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }

        #installBanner p {
            margin: 5px 0;
            font-size: 14px;
            line-height: 1.4;
        }

        #installBanner strong {
            color: #FFD700;
            font-size: 16px;
        }

        #installBanner .close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        /* Multiplayer Menu */
        #menuScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        #menuScreen.hidden {
            display: none;
        }

        .menu-title {
            font-size: 48px;
            color: white;
            margin-bottom: 20px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.3);
        }

        .menu-subtitle {
            font-size: 18px;
            color: rgba(255,255,255,0.9);
            margin-bottom: 40px;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 300px;
        }

        .menu-btn {
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .menu-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .btn-local {
            background: #4CAF50;
            color: white;
        }

        .btn-1v1 {
            background: #9C27B0;
            color: white;
        }

        .btn-random {
            background: #FF9800;
            color: white;
        }

        .btn-private {
            background: #2196F3;
            color: white;
        }

        .btn-back {
            background: #f44336;
            color: white;
            margin-top: 20px;
        }

        /* Room Code Input */
        .room-input-container {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .room-input-container.show {
            display: flex;
        }

        #roomCodeInput {
            padding: 15px;
            font-size: 24px;
            text-align: center;
            border: 3px solid white;
            border-radius: 10px;
            width: 250px;
            letter-spacing: 5px;
            font-weight: bold;
        }

        .waiting-text {
            color: white;
            font-size: 20px;
            margin-top: 20px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .room-code-display {
            background: rgba(255,255,255,0.2);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .room-code-display h3 {
            color: white;
            margin-bottom: 10px;
        }

        .room-code {
            font-size: 36px;
            color: #FFD700;
            letter-spacing: 10px;
            font-weight: bold;
        }

        @media (min-width: 1024px) {
            #installBanner {
                display: none !important;
            }
        }
        
        #gameCanvas {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            position: relative;
            max-width: 100vw;
            max-height: 100vh;
            max-height: 100svh;
            width: 1600px;
            height: 900px;
            border: none;
            box-shadow: none; /* Î‘Ï†Î±Î¯ÏÎµÏƒÎ· ÏƒÎºÎ¹Î¬Ï‚ Î³Î¹Î± Ï€Î¹Î¿ ÎºÎ±Î¸Î±ÏÎ® ÎµÎ¼Ï†Î¬Î½Î¹ÏƒÎ· */
            cursor: pointer;
            transform: scale(0.92) translateY(-50px); /* ÎœÎµÏ„Î±ÎºÎ¯Î½Î·ÏƒÎ· Î±ÎºÏŒÎ¼Î± Ï€Î¹Î¿ Ï€Î¬Î½Ï‰ */
            transform-origin: center;
        }

        /* Responsive canvas */
        @media (max-width: 1600px) {
            #gameCanvas {
                width: 100vw;
                height: auto;
                transform: scale(0.98) translateY(-30px); /* ÎœÎµÎ³Î±Î»ÏÏ„ÎµÏÎ¿ zoom Î¼Îµ vertical scoreboard */
            }
        }

        @media (orientation: portrait) {
            body {
                overflow: auto;
            }
            #gameCanvas {
                width: 100vw;
                height: auto;
                transform: scale(0.88) translateY(-60px); /* Î‘ÎºÏŒÎ¼Î± Ï€Î¹Î¿ Ï€Î¬Î½Ï‰ Î³Î¹Î± mobile */
            }
        }

        #gameCanvas {
            border: none;
            box-shadow: none; /* Î‘Ï†Î±Î¯ÏÎµÏƒÎ· ÏƒÎºÎ¹Î¬Ï‚ */
            cursor: pointer;
            max-width: 100%;
            max-height: 100vh;
            display: none; /* ÎšÏÏ…Ï†ÏŒ Î¼Î­Ï‡ÏÎ¹ Î½Î± Î¾ÎµÎºÎ¹Î½Î®ÏƒÎµÎ¹ Ï„Î¿ Ï€Î±Î¹Ï‡Î½Î¯Î´Î¹ */
        }

        #gameCanvas.active {
            display: block;
        }

        .controls {
            display: none; /* Î‘Ï€ÏŒÎºÏÏ…ÏˆÎ· Î¿Î´Î·Î³Î¹ÏÎ½ */
        }

        .controls h3 {
            margin-bottom: 10px;
            color: #333;
        }

        .controls p {
            margin: 5px 0;
            color: #666;
        }

        /* Back to Menu Button */
        #backToMenuBtn {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #333;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 10000; /* Î Î¿Î»Ï ÏˆÎ·Î»Î¬ Î³Î¹Î± Î½Î± Ï†Î±Î¯Î½ÎµÏ„Î±Î¹ Ï€Î¬Î½Ï„Î± */
            display: none; /* ÎšÏÏ…Ï†ÏŒ ÏƒÏ„Î¿ menu */
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        #backToMenuBtn:hover {
            background: white;
            transform: scale(1.05);
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
        }

        #backToMenuBtn.visible {
            display: block;
        }

        /* Friction Selector - Î Î¬Î½Ï‰ Î´ÎµÎ¾Î¹Î¬ */
        #frictionSelector {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: none;
        }

        #frictionSelector.visible {
            display: block;
        }

        #frictionSelector select {
            padding: 10px 15px;
            font-size: 14px;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #333;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            transition: all 0.3s;
        }

        #frictionSelector select:hover {
            background: white;
            transform: scale(1.02);
        }

        #frictionSelector label {
            color: white;
            font-weight: bold;
            margin-right: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        /* Abilities UI */
        #abilitiesUI {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            display: none;
            gap: 15px;
        }
        
        #abilitiesUI.visible {
            display: flex;
        }
        
        .ability-button {
            padding: 15px 25px;
            font-size: 16px;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: 3px solid white;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
            transition: all 0.3s;
            position: relative;
            min-width: 120px;
        }
        
        .ability-button:hover:not(.disabled) {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 20px rgba(0,0,0,0.5);
        }
        
        .ability-button:active:not(.disabled) {
            transform: translateY(0) scale(0.98);
        }
        
        .ability-button.active {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            animation: pulse 0.5s ease-in-out;
        }
        
        .ability-button.disabled {
            background: #555;
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .ability-count {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #ff3420;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            border: 2px solid white;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Responsive Î³Î¹Î± mobile */
        @media (max-width: 768px) {
            #backToMenuBtn {
                top: 10px;
                left: 10px;
                padding: 10px 20px;
                font-size: 14px;
            }
            
            .ability-button {
                padding: 12px 20px;
                font-size: 14px;
                min-width: 100px;
            }
        }
    </style>
</head>
<body>
    <!-- Floating Ducks Background -->
    <div id="floatingDucks"></div>
    
    <!-- Back to Menu Button -->
    <button id="backToMenuBtn">â¬…ï¸ Back to Menu</button>
    
    <!-- Friction Selector -->
    <div id="frictionSelector">
        <label>âš™ï¸ Friction:</label>
        <select id="frictionSelect" onchange="changeFriction(this.value)">
            <option value="low">Low (0.98 Ball / 0.97 Player)</option>
            <option value="verylow">Very Low (0.985 Ball / 0.98 Player)</option>
            <option value="ice">Ice (0.99 Ball / 0.985 Player)</option>
        </select>
    </div>
    
    <!-- Abilities UI -->
    <div id="abilitiesUI">
        <button id="curveShotBtn" class="ability-button" onclick="activateCurveShot()">
            ğŸŒ€ Curve Shot
            <span class="ability-count" id="curveShotCount">3</span>
        </button>
    </div>
    
    <!-- Multiplayer Menu -->
    <div id="menuScreen">
        <h1 class="menu-title">ğŸ¦† Duck Strike</h1>
        <p class="menu-subtitle">Î”Î¹Î¬Î»ÎµÎ¾Îµ Ï„ÏÏŒÏ€Î¿ Ï€Î±Î¹Ï‡Î½Î¹Î´Î¹Î¿Ï</p>
        
        <div class="menu-buttons" id="mainMenu">
            <button class="menu-btn btn-local" onclick="startLocalGame()">
                ğŸ® Î Î±Î¯Î¾Îµ Î¼Îµ Bot
            </button>
            <button class="menu-btn btn-1v1" onclick="startLocal1v1()">
                ğŸ‘¥ Local 1v1
            </button>
            <button class="menu-btn btn-random" onclick="findRandomMatch()">
                ğŸŒ Î¤Ï…Ï‡Î±Î¯Î¿Ï‚ Î‘Î½Ï„Î¯Ï€Î±Î»Î¿Ï‚
            </button>
            <button class="menu-btn btn-private" onclick="showPrivateRoomMenu()">
                ğŸ” Î™Î´Î¹Ï‰Ï„Î¹ÎºÏŒ Î”Ï‰Î¼Î¬Ï„Î¹Î¿
            </button>
        </div>

        <!-- Private Room Menu -->
        <div class="room-input-container" id="privateRoomMenu">
            <button class="menu-btn btn-private" onclick="createPrivateRoom()">
                â• Î”Î·Î¼Î¹Î¿ÏÏÎ³Î·ÏƒÎµ Î”Ï‰Î¼Î¬Ï„Î¹Î¿
            </button>
            <p style="color: white; margin: 10px 0;">Î®</p>
            <input type="text" id="roomCodeInput" placeholder="Î•Î™Î£Î‘Î“Î• ÎšÎ©Î”Î™ÎšÎŸ" maxlength="6">
            <button class="menu-btn btn-private" onclick="joinPrivateRoom()">
                ğŸšª ÎœÏ€ÎµÏ‚ ÏƒÎµ Î”Ï‰Î¼Î¬Ï„Î¹Î¿
            </button>
            <button class="menu-btn btn-back" onclick="backToMainMenu()">
                â† Î Î¯ÏƒÏ‰
            </button>
        </div>

        <!-- Waiting Screen -->
        <div class="room-input-container" id="waitingScreen">
            <div class="room-code-display">
                <h3>ÎŸ ÎºÏ‰Î´Î¹ÎºÏŒÏ‚ ÏƒÎ¿Ï…:</h3>
                <div class="room-code" id="displayRoomCode"></div>
            </div>
            <p class="waiting-text">â³ Î ÎµÏÎ¹Î¼Î­Î½Î¿Î½Ï„Î±Ï‚ Ï€Î±Î¯ÎºÏ„Î·...</p>
            <button class="menu-btn btn-back" onclick="cancelWaiting()">
                âŒ Î‘ÎºÏÏÏ‰ÏƒÎ·
            </button>
        </div>

        <!-- Random Match Waiting -->
        <div class="room-input-container" id="randomWaiting">
            <p class="waiting-text">ğŸ” Î‘Î½Î±Î¶Î®Ï„Î·ÏƒÎ· Î±Î½Ï„Î¹Ï€Î¬Î»Î¿Ï…...</p>
            <button class="menu-btn btn-back" onclick="cancelWaiting()">
                âŒ Î‘ÎºÏÏÏ‰ÏƒÎ·
            </button>
        </div>
    </div>

    <!-- Install Banner Î³Î¹Î± fullscreen experience -->
    <div id="installBanner">
        <button class="close-btn" onclick="closeBanner()">âœ•</button>
        <p><strong>ğŸ“± Î˜Î­Î»ÎµÎ¹Ï‚ Ï€ÏÎ±Î³Î¼Î±Ï„Î¹ÎºÏŒ Fullscreen;</strong></p>
        <p id="installInstructions">
            <strong>iOS:</strong> Î Î¬Ï„Î± Share â†’ "Add to Home Screen"<br>
            <strong>Android:</strong> Î Î¬Ï„Î± ÎœÎµÎ½Î¿Ï (â‹®) â†’ "Install app"
        </p>
        <button id="installBtn" style="display:none; margin-top:10px; padding:10px 20px; background:#FFD700; color:black; border:none; border-radius:8px; font-weight:bold; font-size:16px; cursor:pointer;">
            â¬‡ï¸ Install App
        </button>
    </div>

    <div class="controls" id="gameControls">
        <h3>ğŸ® ÎŸÎ´Î·Î³Î¯ÎµÏ‚</h3>
        <p id="control-text-1">ğŸ–±ï¸ ÎšÎ»Î¹Îº ÏƒÎµ ÎºÏŒÎºÎºÎ¹Î½Î¿ Ï€Î±Î¯ÎºÏ„Î·</p>
        <p id="control-text-2">â†”ï¸ Î¤ÏÎ¬Î²Î·Î¾Îµ Ï€ÏÎ¿Ï‚ Ï„Î·Î½ Î‘ÎÎ¤Î™Î˜Î•Î¤Î— ÎºÎ±Ï„ÎµÏÎ¸Ï…Î½ÏƒÎ·</p>
        <p id="control-text-3">ğŸš€ ÎŒÏƒÎ¿ Ï€Î¹Î¿ Ï€Î¿Î»Ï Ï„ÏÎ±Î²Î®Î¾ÎµÎ¹Ï‚ = Ï€Î¹Î¿ Î´Ï…Î½Î±Ï„Î¬!</p>
        <p id="control-text-4">âš½ Î£ÎºÏŒÏÎ±ÏÎµ Î³ÎºÎ¿Î» ÏƒÏ„Î¿ Ï„Î­ÏÎ¼Î± Ï„Î¿Ï… BOT!</p>
    </div>    <canvas id="gameCanvas" width="1600" height="900"></canvas>

    <script>
        console.log('Script started!');
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        console.log('Canvas:', canvas);
        console.log('Canvas size:', canvas.width, 'x', canvas.height);

        // ========================
        // FIREBASE CONFIGURATION
        // ========================
        const firebaseConfig = {
            apiKey: "AIzaSyAH3B2vTZw6Sa5lrVoHC9MKtCP5CNxTvA8",
            authDomain: "duck-strike.firebaseapp.com",
            databaseURL: "https://duck-strike-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "duck-strike",
            storageBucket: "duck-strike.firebasestorage.app",
            messagingSenderId: "585501371332",
            appId: "1:585501371332:web:039f2305aa915f089c1291"
        };

        // Initialize Firebase (with error handling)
        let database = null;
        try {
            if (typeof firebase !== 'undefined') {
                firebase.initializeApp(firebaseConfig);
                database = firebase.database();
                console.log('Firebase initialized successfully!');
            } else {
                console.warn('Firebase SDK not loaded - Multiplayer disabled');
            }
        } catch (error) {
            console.error('Firebase initialization failed:', error);
            console.warn('Multiplayer features will be disabled');
        }

        // ========================
        // MULTIPLAYER STATE
        // ========================
        let isMultiplayer = false;
        let isLocal1v1 = false;  // ğŸ‘¥ Local 1v1 mode flag
        let isHost = false;
        let currentRoomId = null;
        let playerId = 'player_' + Math.random().toString(36).substr(2, 9);

        // ========================
        // FRICTION SETTINGS
        // ========================
        let ballFriction = 0.98;  // Default: Low friction
        let playerFriction = 0.97;

        function changeFriction(mode) {
            switch(mode) {
                case 'normal':
                    ballFriction = 0.97;
                    playerFriction = 0.96;
                    break;
                case 'low':
                    ballFriction = 0.98;
                    playerFriction = 0.97;
                    break;
                case 'verylow':
                    ballFriction = 0.985;
                    playerFriction = 0.98;
                    break;
                case 'ice':
                    ballFriction = 0.99;
                    playerFriction = 0.985;
                    break;
            }
            
            // Î•Î½Î·Î¼Î­ÏÏ‰ÏƒÎµ Ï„Î·Î½ Ï„ÏÎ¹Î²Î® ÏƒÏ„Î± Ï…Ï€Î¬ÏÏ‡Î¿Î½Ï„Î± objects
            if (game) {
                if (game.ball) {
                    game.ball.friction = ballFriction;
                }
                game.playerTeam.forEach(p => p.friction = playerFriction);
                game.botTeam.forEach(p => p.friction = playerFriction);
            }
            
            console.log('ğŸ® Friction changed:', mode, '- Ball:', ballFriction, 'Player:', playerFriction);
        }
        
        // Global curve shot state
        let curveShotActive = false;
        let curveShotPoints = null; // Î˜Î± ÎºÏÎ±Ï„Î¬ÎµÎ¹ Ï„Î± 3 ÏƒÎ·Î¼ÎµÎ¯Î± Ï„Î¿Ï… curve
        
        // ========================
        // ABILITIES SYSTEM
        // ========================
        function activateCurveShot() {
            if (!game) {
                console.log('âŒ Game not started');
                return;
            }
            
            // Toggle curve shot mode
            curveShotActive = !curveShotActive;
            
            if (curveShotActive) {
                console.log('âœ… Curve shot mode ENABLED - Shoot to see trajectory with curve points');
            } else {
                console.log('âŒ Curve shot mode DISABLED');
                curveShotPoints = null; // Reset points
            }
            
            updateAbilitiesUI();
        }
        
        function updateAbilitiesUI() {
            const btn = document.getElementById('curveShotBtn');
            const count = document.getElementById('curveShotCount');
            
            // Get current player's remaining shots
            let remainingShots = 3;
            if (game && game.selectedPlayer) {
                remainingShots = game.selectedPlayer.abilities.curveShot;
            } else if (game && game.playerTeam && game.playerTeam.length > 0) {
                // Use first player as reference
                remainingShots = game.playerTeam[0].abilities.curveShot;
            }
            
            // Update count
            count.textContent = remainingShots;
            
            // Update button state
            if (remainingShots <= 0) {
                btn.classList.add('disabled');
                btn.classList.remove('active');
            } else if (curveShotActive) {
                btn.classList.add('active');
                btn.classList.remove('disabled');
            } else {
                btn.classList.remove('active', 'disabled');
            }
        }

        // ========================
        // MENU FUNCTIONS
        // ========================
        function startLocalGame() {
            isMultiplayer = false;
            isLocal1v1 = false;
            
            // Update instructions for bot mode
            document.getElementById('control-text-1').textContent = 'ğŸ–±ï¸ ÎšÎ»Î¹Îº ÏƒÎµ ÎºÏŒÎºÎºÎ¹Î½Î¿ Ï€Î±Î¯ÎºÏ„Î·';
            document.getElementById('control-text-4').textContent = 'âš½ Î£ÎºÏŒÏÎ±ÏÎµ Î³ÎºÎ¿Î» ÏƒÏ„Î¿ Ï„Î­ÏÎ¼Î± Ï„Î¿Ï… BOT!';
            
            document.getElementById('menuScreen').classList.add('hidden');
            document.getElementById('gameCanvas').classList.add('active');
            document.getElementById('backToMenuBtn').classList.add('visible'); // Show back button
            document.getElementById('frictionSelector').classList.add('visible'); // Show friction selector
            document.getElementById('abilitiesUI').classList.add('visible'); // Show abilities UI
            startGame();
        }

        function startLocal1v1() {
            isMultiplayer = false;
            isLocal1v1 = true;  // ğŸ‘¥ Enable local 1v1 mode
            
            // Update instructions for 1v1 mode
            document.getElementById('control-text-1').textContent = 'ğŸ‘¥ ÎšÎ¬Î¸Îµ Ï€Î±Î¯ÎºÏ„Î·Ï‚ Ï€Î±Î¯Î¶ÎµÎ¹ Ï„Î· ÏƒÎµÎ¹ÏÎ¬ Ï„Î¿Ï…';
            document.getElementById('control-text-4').textContent = 'âš½ ÎšÏŒÎºÎºÎ¹Î½Î¿Î¹ vs ÎœÏ€Î»Îµ - Î£ÎºÎ¿ÏÎ¬ÏÎµÏ„Îµ Î³ÎºÎ¿Î»!';
            
            document.getElementById('menuScreen').classList.add('hidden');
            document.getElementById('gameCanvas').classList.add('active');
            document.getElementById('backToMenuBtn').classList.add('visible'); // Show back button
            document.getElementById('frictionSelector').classList.add('visible'); // Show friction selector
            document.getElementById('abilitiesUI').classList.add('visible'); // Show abilities UI
            startGame();
        }

        function backToMenu() {
            // Clean up multiplayer connections
            if (isMultiplayer && currentRoomId && database) {
                database.ref('rooms/' + currentRoomId).remove();
            }
            
            // Stop the game
            if (game) {
                game = null;
            }
            
            // Hide game, show menu
            document.getElementById('gameCanvas').classList.remove('active');
            document.getElementById('menuScreen').classList.remove('hidden');
            document.getElementById('backToMenuBtn').classList.remove('visible'); // Hide back button
            document.getElementById('frictionSelector').classList.remove('visible'); // Hide friction selector
            
            // Show main menu submenu
            document.getElementById('mainMenu').style.display = 'flex';
            document.getElementById('privateRoomMenu').classList.remove('show');
            document.getElementById('waitingScreen').classList.remove('show');
            
            // Reset flags
            isMultiplayer = false;
            isLocal1v1 = false;
            isHost = false;
            currentRoomId = null;
            
            // Clear canvas
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function showPrivateRoomMenu() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('privateRoomMenu').classList.add('show');
        }

        function backToMainMenu() {
            document.getElementById('mainMenu').style.display = 'flex';
            document.getElementById('privateRoomMenu').classList.remove('show');
            document.getElementById('waitingScreen').classList.remove('show');
            document.getElementById('randomWaiting').classList.remove('show');
        }

        function createPrivateRoom() {
            if (!database) {
                alert('Firebase Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î¿! Î”Î¿ÎºÎ¯Î¼Î±ÏƒÎµ "Î Î±Î¯Î¾Îµ Î¼Îµ Bot"');
                return;
            }
            
            const roomCode = generateRoomCode();
            currentRoomId = 'private_' + roomCode;
            isHost = true;
            isMultiplayer = true;

            // Create room in Firebase
            database.ref('rooms/' + currentRoomId).set({
                host: playerId,
                guest: null,
                status: 'waiting',
                gameState: null,
                createdAt: Date.now()
            });

            // Show waiting screen
            document.getElementById('privateRoomMenu').classList.remove('show');
            document.getElementById('waitingScreen').classList.add('show');
            document.getElementById('displayRoomCode').textContent = roomCode;

            // Listen for guest joining
            database.ref('rooms/' + currentRoomId + '/guest').on('value', (snapshot) => {
                if (snapshot.val()) {
                    startMultiplayerGame();
                }
            });
        }

        function joinPrivateRoom() {
            if (!database) {
                alert('Firebase Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î¿! Î”Î¿ÎºÎ¯Î¼Î±ÏƒÎµ "Î Î±Î¯Î¾Îµ Î¼Îµ Bot"');
                return;
            }
            
            const roomCode = document.getElementById('roomCodeInput').value.toUpperCase();
            if (roomCode.length !== 6) {
                alert('Î•Î¹ÏƒÎ¬Î³Î±Î³Îµ Î­Î³ÎºÏ…ÏÎ¿ ÎºÏ‰Î´Î¹ÎºÏŒ 6 Ï‡Î±ÏÎ±ÎºÏ„Î®ÏÏ‰Î½!');
                return;
            }

            currentRoomId = 'private_' + roomCode;
            isHost = false;
            isMultiplayer = true;

            // Check if room exists
            database.ref('rooms/' + currentRoomId).once('value').then((snapshot) => {
                if (snapshot.exists() && snapshot.val().status === 'waiting') {
                    // Join room
                    database.ref('rooms/' + currentRoomId + '/guest').set(playerId);
                    database.ref('rooms/' + currentRoomId + '/status').set('playing');
                    startMultiplayerGame();
                } else {
                    alert('Î¤Î¿ Î´Ï‰Î¼Î¬Ï„Î¹Î¿ Î´ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎµ Î® ÎµÎ¯Î½Î±Î¹ Î³ÎµÎ¼Î¬Ï„Î¿!');
                }
            });
        }

        function findRandomMatch() {
            if (!database) {
                alert('Firebase Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î´Î¹Î±Î¸Î­ÏƒÎ¹Î¼Î¿! Î”Î¿ÎºÎ¯Î¼Î±ÏƒÎµ "Î Î±Î¯Î¾Îµ Î¼Îµ Bot"');
                return;
            }
            
            isMultiplayer = true;
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('randomWaiting').classList.add('show');

            // Look for available room or create one
            database.ref('rooms').orderByChild('status').equalTo('waiting').limitToFirst(1).once('value').then((snapshot) => {
                if (snapshot.exists()) {
                    // Join existing room
                    const roomId = Object.keys(snapshot.val())[0];
                    if (!roomId.startsWith('private_')) {
                        currentRoomId = roomId;
                        isHost = false;
                        database.ref('rooms/' + currentRoomId + '/guest').set(playerId);
                        database.ref('rooms/' + currentRoomId + '/status').set('playing');
                        startMultiplayerGame();
                    } else {
                        createRandomRoom();
                    }
                } else {
                    // Create new room
                    createRandomRoom();
                }
            });
        }

        function createRandomRoom() {
            currentRoomId = 'random_' + Math.random().toString(36).substr(2, 9);
            isHost = true;

            database.ref('rooms/' + currentRoomId).set({
                host: playerId,
                guest: null,
                status: 'waiting',
                gameState: null,
                createdAt: Date.now()
            });

            // Listen for guest joining
            database.ref('rooms/' + currentRoomId + '/guest').on('value', (snapshot) => {
                if (snapshot.val()) {
                    startMultiplayerGame();
                }
            });
        }

        function cancelWaiting() {
            if (currentRoomId) {
                database.ref('rooms/' + currentRoomId).remove();
            }
            backToMainMenu();
        }

        function generateRoomCode() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }

        function startMultiplayerGame() {
            document.getElementById('menuScreen').classList.add('hidden');
            document.getElementById('gameCanvas').classList.add('active');
            document.getElementById('backToMenuBtn').classList.add('visible'); // Show back button
            document.getElementById('frictionSelector').classList.add('visible'); // Show friction selector
            document.getElementById('abilitiesUI').classList.add('visible'); // Show abilities UI
            startGame();
            setupMultiplayerSync();
        }

        function setupMultiplayerSync() {
            // Sync game state in real-time
            if (isHost) {
                // Host sends game state
                setInterval(() => {
                    if (game) {
                        const gameState = {
                            ball: { x: game.ball.x, y: game.ball.y, vx: game.ball.vx, vy: game.ball.vy },
                            playerTeam: game.playerTeam.map(p => ({ x: p.x, y: p.y, vx: p.vx, vy: p.vy })),
                            botTeam: game.botTeam.map(p => ({ x: p.x, y: p.y, vx: p.vx, vy: p.vy })),
                            score: { player: game.playerScore, bot: game.botScore },
                            currentTurn: game.currentTurn,
                            turnComplete: game.turnComplete
                        };
                        database.ref('rooms/' + currentRoomId + '/gameState').set(gameState);
                    }
                }, 50); // 20 updates per second
            } else {
                // Guest receives game state
                database.ref('rooms/' + currentRoomId + '/gameState').on('value', (snapshot) => {
                    const state = snapshot.val();
                    if (state && game) {
                        // Sync ball
                        game.ball.x = state.ball.x;
                        game.ball.y = state.ball.y;
                        game.ball.vx = state.ball.vx;
                        game.ball.vy = state.ball.vy;
                        
                        // Sync players
                        state.playerTeam.forEach((p, i) => {
                            if (game.playerTeam[i]) {
                                game.playerTeam[i].x = p.x;
                                game.playerTeam[i].y = p.y;
                                game.playerTeam[i].vx = p.vx;
                                game.playerTeam[i].vy = p.vy;
                            }
                        });
                        
                        state.botTeam.forEach((p, i) => {
                            if (game.botTeam[i]) {
                                game.botTeam[i].x = p.x;
                                game.botTeam[i].y = p.y;
                                game.botTeam[i].vx = p.vx;
                                game.botTeam[i].vy = p.vy;
                            }
                        });
                        
                        // Sync score & turn
                        game.playerScore = state.score.player;
                        game.botScore = state.score.bot;
                        game.currentTurn = state.currentTurn;
                        game.turnComplete = state.turnComplete;
                    }
                });
            }
            
            // Both players listen for opponent's shots
            database.ref('rooms/' + currentRoomId + '/lastShot').on('value', (snapshot) => {
                const shot = snapshot.val();
                if (shot && game && shot.team !== game.myTeam) {
                    // Opponent shot - apply it
                    const team = shot.team === 'player' ? game.playerTeam : game.botTeam;
                    const player = team[shot.playerIndex];
                    if (player && game.turnComplete) {
                        player.shoot(shot.dragX, shot.dragY);
                        game.turnComplete = false;
                    }
                }
            });
        }

        // Register Service Worker Î³Î¹Î± PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then((registration) => {
                        console.log('ServiceWorker registration successful:', registration.scope);
                    })
                    .catch((err) => {
                        console.log('ServiceWorker registration failed:', err);
                    });
            });
        }

        // PWA Install Prompt
        let deferredPrompt;
        const installBtn = document.getElementById('installBtn');
        const installInstructions = document.getElementById('installInstructions');
        
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent the mini-infobar from appearing on mobile
            e.preventDefault();
            // Stash the event so it can be triggered later
            deferredPrompt = e;
            console.log('Install prompt available!');
            
            // Î‘Î½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ PWA prompt, ÎºÏÏÏˆÎµ manual instructions ÎºÎ±Î¹ Î´ÎµÎ¯Î¾Îµ Ï„Î¿ button
            installInstructions.style.display = 'none';
            installBtn.style.display = 'block';
        });

        // Install button click handler
        installBtn.addEventListener('click', async () => {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                console.log(`User response: ${outcome}`);
                deferredPrompt = null;
                closeBanner(); // ÎšÎ»ÎµÎ¯ÏƒÎµ Ï„Î¿ banner Î¼ÎµÏ„Î¬ Ï„Î¿ install
            }
        });

        // Check if already installed
        window.addEventListener('appinstalled', () => {
            closeBanner();
            console.log('PWA installed successfully!');
        });

        // Install Banner Logic
        const installBanner = document.getElementById('installBanner');
        
        // Close banner function
        window.closeBanner = function() {
            installBanner.classList.remove('show');
            localStorage.setItem('bannerClosed', 'true');
        };

        // Show banner on mobile (only if not standalone and not closed before)
        window.addEventListener('load', () => {
            // Check if running as standalone app (already installed)
            const isStandalone = window.matchMedia('(display-mode: standalone)').matches || 
                                window.navigator.standalone === true;
            
            // Check if on mobile
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            
            // Check if user closed it before
            const bannerClosed = localStorage.getItem('bannerClosed');
            
            // Show banner if: mobile AND not standalone AND not closed before
            if (isMobile && !isStandalone && !bannerClosed) {
                setTimeout(() => {
                    installBanner.classList.add('show');
                    
                    // Auto-hide after 8 seconds
                    setTimeout(() => {
                        installBanner.classList.remove('show');
                    }, 8000);
                }, 2000); // Show after 2 seconds
            }
            
            // Auto-hide address bar
            setTimeout(() => {
                window.scrollTo(0, 1);
            }, 100);
        });

        // Î§ÏÏÎ¼Î±Ï„Î±
        const COLORS = {
            green: '#00C853',  // Î Î¹Î¿ Î¶Ï‰Î½Ï„Î±Î½ÏŒ, Ï†Ï‰Ï„ÎµÎ¹Î½ÏŒ Ï€ÏÎ¬ÏƒÎ¹Î½Î¿ (Î±Ï€ÏŒ #4caf50)
            white: '#ffffff',
            black: '#000000',
            red: '#f44336',
            blue: '#2196f3',
            cyan: '#00e5ff',
            orange: '#000000', // ÎœÎ±ÏÏÎ¿ Î±Î½Ï„Î¯ Î³Î¹Î± ÏÎ¿Î¶
            darkGrey: '#424242',
            lightBlue: '#64b5f6',
            lightRed: '#ff8a80'
        };

        // Î¦ÏŒÏÏ„Ï‰ÏƒÎ· ÎµÎ¹ÎºÏŒÎ½Ï‰Î½
        const images = {
            duckRed: new Image(),
            duckBlue: new Image()
        };
        
        images.duckRed.src = './assets/duck_red.png';
        images.duckBlue.src = './assets/duck_blue.png';
        
        // Î‘Î½Î±Î¼Î¿Î½Î® Ï†ÏŒÏÏ„Ï‰ÏƒÎ·Ï‚ ÎµÎ¹ÎºÏŒÎ½Ï‰Î½
        let imagesLoaded = 0;
        const totalImages = 2;
        
        images.duckRed.onload = () => {
            imagesLoaded++;
            console.log('Duck Red loaded!');
            // Î•Î¹ÎºÏŒÎ½ÎµÏ‚ Ï†Î¿ÏÏ„Ï‰Î¼Î­Î½ÎµÏ‚ - ÎµÎ¼Ï†Î¬Î½Î¹ÏƒÎµ Ï„Î¿ menu (Î”Î•Î Î¾ÎµÎºÎ¹Î½Î¬Î¼Îµ auto!)
            if (imagesLoaded === totalImages) {
                console.log('All images loaded! Menu ready.');
            }
        };
        
        images.duckBlue.onload = () => {
            imagesLoaded++;
            console.log('Duck Blue loaded!');
            // Î•Î¹ÎºÏŒÎ½ÎµÏ‚ Ï†Î¿ÏÏ„Ï‰Î¼Î­Î½ÎµÏ‚ - ÎµÎ¼Ï†Î¬Î½Î¹ÏƒÎµ Ï„Î¿ menu (Î”Î•Î Î¾ÎµÎºÎ¹Î½Î¬Î¼Îµ auto!)
            if (imagesLoaded === totalImages) {
                console.log('All images loaded! Menu ready.');
            }
        };
        
        images.duckRed.onerror = () => {
            console.error('Failed to load duck_red.png - Check path: ./assets/duck_red.png');
        };
        
        images.duckBlue.onerror = () => {
            console.error('Failed to load duck_blue.png - Check path: ./assets/duck_blue.png');
        };

        // ÎœÏ€Î¬Î»Î±
        class Ball {
            constructor() {
                this.reset();
                this.radius = 15;
                this.friction = ballFriction;  // Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯ Ï„Î¿ global ballFriction
                this.firstShotAfterReset = true;  // Flag Î³Î¹Î± Ï€ÏÏÏ„Î¿ shot Î¼ÎµÏ„Î¬ reset
                this.inGoal = false;  // Flag Î±Î½ Î· Î¼Ï€Î¬Î»Î± ÎµÎ¯Î½Î±Î¹ Î¼Î­ÏƒÎ± ÏƒÏ„Î¿ Ï„Î­ÏÎ¼Î±
                this.goalType = null;  // Î¤ÏÏ€Î¿Ï‚ Î³ÎºÎ¿Î» ('player_goal', 'bot_goal', ÎºÏ„Î»)
                this.goalTime = 0;  // Î§ÏÏŒÎ½Î¿Ï‚ Ï€Î¿Ï… Î¼Ï€Î®ÎºÎµ Î³ÎºÎ¿Î»
                
                // Curve Shot Effect
                this.curveForce = 0;  // Î”ÏÎ½Î±Î¼Î· ÎºÎ±Î¼Ï€ÏÎ»Î·Ï‚
                this.curveDecay = 0.97;  // Î ÏŒÏƒÎ¿ Î³ÏÎ®Î³Î¿ÏÎ± ÎµÎ¾Î±ÏƒÎ¸ÎµÎ½ÎµÎ¯ Ï„Î¿ curve
                this.curveDirectionX = 0;  // Custom curve direction X
                this.curveDirectionY = 0;  // Custom curve direction Y
            }

            reset() {
                // ÎšÎ­Î½Ï„ÏÎ¿ Ï„Î¿Ï… Î³Î·Ï€Î­Î´Î¿Ï… (ÏŒÏ‡Î¹ Ï„Î¿Ï… canvas)
                const topMargin = 180;
                const bottomMargin = 80;
                this.x = canvas.width / 2;
                this.y = (topMargin + (canvas.height - bottomMargin)) / 2;  // ÎšÎ­Î½Ï„ÏÎ¿ Î³Î·Ï€Î­Î´Î¿Ï…
                this.vx = 0;
                this.vy = 0;
                this.firstShotAfterReset = true;  // Î•Ï€Î±Î½Î±Ï†Î¿ÏÎ¬ flag Î¼ÎµÏ„Î¬ Î±Ï€ÏŒ reset
                this.inGoal = false;
                this.goalType = null;
                this.goalTime = 0;
            }

            update() {
                // Î‘Î½ Î· Î¼Ï€Î¬Î»Î± ÎµÎ¯Î½Î±Î¹ Î¼Î­ÏƒÎ± ÏƒÏ„Î¿ Ï„Î­ÏÎ¼Î±, ÎµÏ€Î¹Î²ÏÎ¬Î´Ï…Î½ÏƒÎ· Î´ÏÎ±Î¼Î±Ï„Î¹ÎºÎ® (Î´Î¯Ï‡Ï„Ï…)
                if (this.inGoal) {
                    this.vx *= 0.75;  // Î‘ÎºÏŒÎ¼Î± Ï€Î¹Î¿ Î¼ÎµÎ³Î¬Î»Î· ÎµÏ€Î¹Î²ÏÎ¬Î´Ï…Î½ÏƒÎ·
                    this.vy *= 0.75;
                    
                    // Î‘Î½ Î· Ï„Î±Ï‡ÏÏ„Î·Ï„Î± ÎµÎ¯Î½Î±Î¹ Ï€Î¿Î»Ï Î¼Î¹ÎºÏÎ®, ÏƒÏ„Î±Î¼Î¬Ï„Î± ÎµÎ½Ï„ÎµÎ»ÏÏ‚
                    if (Math.abs(this.vx) < 0.5) this.vx = 0;
                    if (Math.abs(this.vy) < 0.5) this.vy = 0;
                    
                    // ÎœÎµÏ„Î¬ Î±Ï€ÏŒ 0.5 Î´ÎµÏ…Ï„ÎµÏÏŒÎ»ÎµÏ€Ï„Î±, ÎµÏ€Î¹ÏƒÏ„ÏÎ¿Ï†Î® Ï„Î¿Ï… goalType
                    if (Date.now() - this.goalTime >= 500) {
                        return this.goalType;  // Î•Ï€Î¹ÏƒÏ„ÏÎ¿Ï†Î® Ï„Î¿Ï… Ï„ÏÏ€Î¿Ï… Î³ÎºÎ¿Î»
                    }
                }
                
                // Sub-stepping Î³Î¹Î± Ï€Î¹Î¿ Î±ÎºÏÎ¹Î²Î® collision detection
                const substeps = 5;
                
                for (let i = 0; i < substeps; i++) {
                    this.x += this.vx / substeps;
                    this.y += this.vy / substeps;
                    
                    // Curve Shot Effect - Ï€ÏÎ¿ÏƒÎ¸Î­Ï„ÎµÎ¹ ÎºÎ±Î¼Ï€ÏÎ»Î· ÏƒÏ„Î·Î½ Ï„ÏÎ¿Ï‡Î¹Î¬
                    if (Math.abs(this.curveForce) > 0.01) {
                        const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                        if (speed > 0.5) {
                            // Î‘Î½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ custom direction, Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¯Î·ÏƒÎ­ Ï„Î·Î½
                            if (Math.abs(this.curveDirectionX) > 0.01 || Math.abs(this.curveDirectionY) > 0.01) {
                                // Custom curve direction Î±Ï€ÏŒ Ï„Î¿ drag Ï„Î¿Ï… Ï€Î±Î¯ÎºÏ„Î·
                                this.vx += this.curveDirectionX * this.curveForce * 0.4;
                                this.vy += this.curveDirectionY * this.curveForce * 0.4;
                            } else {
                                // Auto curve - ÎºÎ¬Î¸ÎµÏ„Î¿ ÏƒÏ„Î·Î½ ÎºÎ±Ï„ÎµÏÎ¸Ï…Î½ÏƒÎ· ÎºÎ¯Î½Î·ÏƒÎ·Ï‚
                                const perpX = -this.vy / speed;
                                const perpY = this.vx / speed;
                                this.vx += perpX * this.curveForce * 0.3;
                                this.vy += perpY * this.curveForce * 0.3;
                            }
                            
                            // Decay Ï„Î¿Ï… curve effect
                            this.curveForce *= this.curveDecay;
                        } else {
                            this.curveForce = 0;
                            this.curveDirectionX = 0;
                            this.curveDirectionY = 0;
                        }
                    }
                    
                    // ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ Î¿ÏÎ¯Ï‰Î½ ÎœÎ•Î£Î‘ ÏƒÏ„Î¿ substep loop Î³Î¹Î± Ï€Î¹Î¿ Î±ÎºÏÎ¹Î²Î® detection
                    this.checkBoundaries();
                }
                
                // Easing function - Exponential decay Î³Î¹Î± Ï€Î¹Î¿ Ï†Ï…ÏƒÎ¹ÎºÎ® ÎµÏ€Î¹Î²ÏÎ¬Î´Ï…Î½ÏƒÎ·
                if (!this.inGoal) {  // ÎœÏŒÎ½Î¿ Î±Î½ Î”Î•Î ÎµÎ¯Î½Î±Î¹ ÏƒÏ„Î¿ Ï„Î­ÏÎ¼Î±
                    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                    
                    // Î‘Ï…Î¾Î·Î¼Î­Î½Î¿ threshold (Î±Ï€ÏŒ 0.1 ÏƒÎµ 0.6) Î³Î¹Î± Ï€Î¹Î¿ Î±Ï€ÏŒÏ„Î¿Î¼Î· ÏƒÏ„Î¬ÏƒÎ·
                    if (speed > 0.6) {
                        const decayFactor = Math.pow(this.friction, 1.0);  // Î“ÏÎ±Î¼Î¼Î¹ÎºÎ® Î±Ï€ÏŒÏƒÎ²ÎµÏƒÎ· (Î±Ï€ÏŒ 1.2)
                        this.vx *= decayFactor;
                        this.vy *= decayFactor;
                    } else {
                        // Î‘Ï€ÏŒÏ„Î¿Î¼Î· ÏƒÏ„Î¬ÏƒÎ· ÏŒÏ„Î±Î½ Î· Ï„Î±Ï‡ÏÏ„Î·Ï„Î± < 0.6
                        this.vx = 0;
                        this.vy = 0;
                    }
                }

                return null;
            }

            checkBoundaries() {
                // ÎÎ­Î± ÏŒÏÎ¹Î± Î³Î·Ï€Î­Î´Î¿Ï…
                const sideMargin = 240;
                const topMargin = 180;
                const bottomMargin = 80;
                
                // Î¥Ï€Î¿Î»Î¿Î³Î¹ÏƒÎ¼ÏŒÏ‚ Î¸Î­ÏƒÎ·Ï‚ ÎºÎ­Î½Ï„ÏÎ¿Ï… Î³Î¹Î± Ï„Î¿Ï…Ï‚ ÎµÎ»Î­Î³Ï‡Î¿Ï…Ï‚
                const centerX = canvas.width / 2;
                const centerY = (topMargin + (canvas.height - bottomMargin)) / 2;
                
                // Î£ÏÎ½Î¿ÏÎ± Ï€Î¬Î½Ï‰-ÎºÎ¬Ï„Ï‰
                if (this.y - this.radius < topMargin) {
                    this.y = topMargin + this.radius;
                    this.vy *= -0.6;
                } else if (this.y + this.radius > canvas.height - bottomMargin) {
                    this.y = canvas.height - bottomMargin - this.radius;
                    this.vy *= -0.6;
                }

                // Î¤Î­ÏÎ¼Î±Ï„Î± - Î‘ÏÎ¹ÏƒÏ„ÎµÏÎ¬ ÎºÎ±Î¹ Î”ÎµÎ¾Î¹Î¬ - Î— Î¼Ï€Î¬Î»Î± Î¼Ï€Î±Î¯Î½ÎµÎ¹ Î¼Î­ÏƒÎ±!
                const fieldCenterY = (topMargin + (canvas.height - bottomMargin)) / 2;
                const goalHeight = 180;
                const goalTop = fieldCenterY - (goalHeight / 2);
                const goalBottom = fieldCenterY + (goalHeight / 2);
                const goalDepth = 60;  // Î’Î¬Î¸Î¿Ï‚ Ï„Î­ÏÎ¼Î±Ï„Î¿Ï‚ (Ï€ÏŒÏƒÎ¿ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Î¼Ï€ÎµÎ¹ Î· Î¼Ï€Î¬Î»Î± Ï€Î¯ÏƒÏ‰)
                
                // Î‘ÏÎ¹ÏƒÏ„ÎµÏÏŒ Ï„Î­ÏÎ¼Î± (Player ÏƒÎºÎ¿ÏÎ¬ÏÎµÎ¹) - ÎŸÎ»ÏŒÎºÎ»Î·ÏÎ· Î· Î¼Ï€Î¬Î»Î± Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Ï€ÎµÏÎ¬ÏƒÎµÎ¹
                if (this.x + this.radius < sideMargin && this.y > goalTop && this.y < goalBottom) {  
                    // ÎœÏ€Î¬Î»Î± Î¼Ï€Î®ÎºÎµ ÏƒÏ„Î¿ Ï„Î­ÏÎ¼Î±!
                    if (!this.inGoal) {  // Î ÏÏÏ„Î· Ï†Î¿ÏÎ¬ Ï€Î¿Ï… Î¼Ï€Î±Î¯Î½ÎµÎ¹
                        this.inGoal = true;
                        this.goalTime = Date.now();
                        
                        // ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ Î¦Î‘ÎŸÎ¥Î›
                        if (this.firstShotAfterReset) {
                            this.goalType = 'foul_player_goal';
                        } else {
                            this.goalType = 'player_goal';
                        }
                    }
                    
                    // ÎŒÏÎ¹Î¿ Ï€Î¯ÏƒÏ‰ Î³ÏÎ±Î¼Î¼Î®Ï‚ Ï„Î­ÏÎ¼Î±Ï„Î¿Ï‚ (Î±ÏÎ¹ÏƒÏ„ÎµÏÎ¬) - Î£Î¤Î‘ÎœÎ‘Î¤Î‘ Î•Î”Î©!
                    const backLine = sideMargin - goalDepth;
                    if (this.x - this.radius <= backLine) {
                        this.x = backLine + this.radius;
                        this.vx = 0;  // Î Î›Î—Î¡Î—Î£ Î£Î¤Î‘Î£Î—
                        this.vy = 0;  // Î Î›Î—Î¡Î—Î£ Î£Î¤Î‘Î£Î— ÎºÎ±Î¹ ÎºÎ±Ï„Î±ÎºÏŒÏÏ…Ï†Î±
                    }
                    
                    // ğŸš¨ EXTREME SAFETY: Î‘Î½ Î· Î¼Ï€Î¬Î»Î± Ï€Î¬ÎµÎ¹ Ï€Î¯ÏƒÏ‰ Î±Ï€ÏŒ Ï„Î¿ backLine (edge case)
                    if (this.x < backLine) {
                        this.x = backLine + this.radius;
                        this.vx = 0;
                        this.vy = 0;
                    }
                    
                    // ÎŒÏÎ¹Î± Ï€Î¬Î½Ï‰-ÎºÎ¬Ï„Ï‰ Î¼Î­ÏƒÎ± ÏƒÏ„Î¿ Ï„Î­ÏÎ¼Î± - Î£ÎšÎ›Î—Î¡Î‘ ÎŸÎ¡Î™Î‘
                    if (this.y - this.radius <= goalTop) {
                        this.y = goalTop + this.radius;
                        this.vy = 0;  // Î Î›Î—Î¡Î—Î£ Î£Î¤Î‘Î£Î—
                    }
                    if (this.y + this.radius >= goalBottom) {
                        this.y = goalBottom - this.radius;
                        this.vy = 0;  // Î Î›Î—Î¡Î—Î£ Î£Î¤Î‘Î£Î—
                    }
                    
                    return;  // ÎŒÏ‡Î¹ null, Î±Ï€Î»Î¬ return
                }
                
                // Bounce Î±Ï€ÏŒ Ï„Î¿Î½ Î±ÏÎ¹ÏƒÏ„ÎµÏÏŒ Ï„Î¿Î¯Ï‡Î¿ (ÎµÎºÏ„ÏŒÏ‚ Ï„Î­ÏÎ¼Î±Ï„Î¿Ï‚)
                if (this.x - this.radius < sideMargin && this.x + this.radius >= sideMargin) {
                    if (this.y < goalTop || this.y > goalBottom) {
                        this.x = sideMargin + this.radius;
                        this.vx *= -0.6;
                    }
                }
                
                // Î”ÎµÎ¾Î¯ Ï„Î­ÏÎ¼Î± (Bot ÏƒÎºÎ¿ÏÎ¬ÏÎµÎ¹) - ÎŸÎ»ÏŒÎºÎ»Î·ÏÎ· Î· Î¼Ï€Î¬Î»Î± Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Ï€ÎµÏÎ¬ÏƒÎµÎ¹
                if (this.x - this.radius > canvas.width - sideMargin && this.y > goalTop && this.y < goalBottom) {  
                    // ÎœÏ€Î¬Î»Î± Î¼Ï€Î®ÎºÎµ ÏƒÏ„Î¿ Ï„Î­ÏÎ¼Î±!
                    if (!this.inGoal) {  // Î ÏÏÏ„Î· Ï†Î¿ÏÎ¬ Ï€Î¿Ï… Î¼Ï€Î±Î¯Î½ÎµÎ¹
                        this.inGoal = true;
                        this.goalTime = Date.now();
                        
                        // ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ Î¦Î‘ÎŸÎ¥Î›
                        if (this.firstShotAfterReset) {
                            this.goalType = 'foul_bot_goal';
                        } else {
                            this.goalType = 'bot_goal';
                        }
                    }
                    
                    // ÎŒÏÎ¹Î¿ Ï€Î¯ÏƒÏ‰ Î³ÏÎ±Î¼Î¼Î®Ï‚ Ï„Î­ÏÎ¼Î±Ï„Î¿Ï‚ (Î´ÎµÎ¾Î¹Î¬) - Î£Î¤Î‘ÎœÎ‘Î¤Î‘ Î•Î”Î©!
                    const backLine = canvas.width - sideMargin + goalDepth;
                    if (this.x + this.radius >= backLine) {
                        this.x = backLine - this.radius;
                        this.vx = 0;  // Î Î›Î—Î¡Î—Î£ Î£Î¤Î‘Î£Î—
                        this.vy = 0;  // Î Î›Î—Î¡Î—Î£ Î£Î¤Î‘Î£Î— ÎºÎ±Î¹ ÎºÎ±Ï„Î±ÎºÏŒÏÏ…Ï†Î±
                    }
                    
                    // ğŸš¨ EXTREME SAFETY: Î‘Î½ Î· Î¼Ï€Î¬Î»Î± Ï€Î¬ÎµÎ¹ Ï€Î¯ÏƒÏ‰ Î±Ï€ÏŒ Ï„Î¿ backLine (edge case)
                    if (this.x > backLine) {
                        this.x = backLine - this.radius;
                        this.vx = 0;
                        this.vy = 0;
                    }
                    
                    // ÎŒÏÎ¹Î± Ï€Î¬Î½Ï‰-ÎºÎ¬Ï„Ï‰ Î¼Î­ÏƒÎ± ÏƒÏ„Î¿ Ï„Î­ÏÎ¼Î± - Î£ÎšÎ›Î—Î¡Î‘ ÎŸÎ¡Î™Î‘
                    if (this.y - this.radius <= goalTop) {
                        this.y = goalTop + this.radius;
                        this.vy = 0;  // Î Î›Î—Î¡Î—Î£ Î£Î¤Î‘Î£Î—
                    }
                    if (this.y + this.radius >= goalBottom) {
                        this.y = goalBottom - this.radius;
                        this.vy = 0;  // Î Î›Î—Î¡Î—Î£ Î£Î¤Î‘Î£Î—
                    }
                    
                    return;  // ÎŒÏ‡Î¹ null, Î±Ï€Î»Î¬ return
                }
                
                // Bounce Î±Ï€ÏŒ Ï„Î¿Î½ Î´ÎµÎ¾Î¯ Ï„Î¿Î¯Ï‡Î¿ (ÎµÎºÏ„ÏŒÏ‚ Ï„Î­ÏÎ¼Î±Ï„Î¿Ï‚)
                if (this.x + this.radius > canvas.width - sideMargin && this.x - this.radius <= canvas.width - sideMargin) {
                    if (this.y < goalTop || this.y > goalBottom) {
                        this.x = canvas.width - sideMargin - this.radius;
                        this.vx *= -0.6;
                    }
                }
                
                // ğŸš¨ ULTIMATE SAFETY NET - Î•Ï€Î¹Î²Î¿Î»Î® ÏƒÎºÎ»Î·ÏÏÎ½ Î¿ÏÎ¯Ï‰Î½ (Î³Î¹Î± fast-moving balls)
                // Î‘ÏÎ¹ÏƒÏ„ÎµÏÏŒ ÏŒÏÎ¹Î¿ (ÎµÎºÏ„ÏŒÏ‚ Ï„Î­ÏÎ¼Î±Ï„Î¿Ï‚)
                if (this.x - this.radius < sideMargin && (this.y < goalTop || this.y > goalBottom)) {
                    this.x = sideMargin + this.radius;
                    this.vx = Math.abs(this.vx) * 0.6; // Bounce Î´ÎµÎ¾Î¹Î¬
                }
                
                // Î”ÎµÎ¾Î¯ ÏŒÏÎ¹Î¿ (ÎµÎºÏ„ÏŒÏ‚ Ï„Î­ÏÎ¼Î±Ï„Î¿Ï‚)
                if (this.x + this.radius > canvas.width - sideMargin && (this.y < goalTop || this.y > goalBottom)) {
                    this.x = canvas.width - sideMargin - this.radius;
                    this.vx = -Math.abs(this.vx) * 0.6; // Bounce Î±ÏÎ¹ÏƒÏ„ÎµÏÎ¬
                }
                
                // Î Î¬Î½Ï‰ ÏŒÏÎ¹Î¿
                if (this.y - this.radius < topMargin) {
                    this.y = topMargin + this.radius;
                    this.vy = Math.abs(this.vy) * 0.6; // Bounce ÎºÎ¬Ï„Ï‰
                }
                
                // ÎšÎ¬Ï„Ï‰ ÏŒÏÎ¹Î¿
                if (this.y + this.radius > canvas.height - bottomMargin) {
                    this.y = canvas.height - bottomMargin - this.radius;
                    this.vy = -Math.abs(this.vy) * 0.6; // Bounce Ï€Î¬Î½Ï‰
                }
                
                // ğŸš¨ EXTREME EMERGENCY - Î‘Î½ Ï€Î±ÏÏŒÎ»Î± Î±Ï…Ï„Î¬ Î· Î¼Ï€Î¬Î»Î± Î­Ï†Ï…Î³Îµ ÎµÎºÏ„ÏŒÏ‚ canvas
                const safetyMargin = 50;
                if (this.x < -safetyMargin || this.x > canvas.width + safetyMargin ||
                    this.y < -safetyMargin || this.y > canvas.height + safetyMargin) {
                    console.error('âš ï¸ Ball escaped beyond safety margin! Position:', this.x, this.y);
                    this.reset();
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = COLORS.black;
                ctx.fill();
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius - 3, 0, Math.PI * 2);
                ctx.fillStyle = COLORS.white;
                ctx.fill();
            }
        }

        // Î Î±Î¯ÎºÏ„Î·Ï‚
        class Player {
            constructor(x, y, color, isBot = false) {
                this.x = x;
                this.y = y;
                this.startX = x;  // Î‘ÏÏ‡Î¹ÎºÎ® Î¸Î­ÏƒÎ· (ÏƒÏ„Î±Î¸ÎµÏÎ®)
                this.startY = y;  // Î‘ÏÏ‡Î¹ÎºÎ® Î¸Î­ÏƒÎ· (ÏƒÏ„Î±Î¸ÎµÏÎ®)
                this.radius = 30;
                this.color = color;
                this.isBot = isBot;
                this.selected = false;
                this.vx = 0;  // Î¤Î±Ï‡ÏÏ„Î·Ï„Î±
                this.vy = 0;
                this.friction = playerFriction;  // Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯ Ï„Î¿ global playerFriction
                this.moving = false;
                this.collisionCooldown = {};  // Cooldown Î±Î½Î¬ Ï€Î±Î¯ÎºÏ„Î· Î³Î¹Î± Î½Î± Î¼Î·Î½ ÎºÎ¿Î»Î»Î¬Î½Îµ
                this.ballCollisionTime = 0;  // Cooldown Î³Î¹Î± Ï„Î·Î½ Î¼Ï€Î¬Î»Î±
                this.isRelocating = false;  // Flag Î³Î¹Î± animation Î¼ÎµÏ„Î±ÎºÎ¯Î½Î·ÏƒÎ·Ï‚
                this.relocateTarget = null;  // Î ÏÎ¿Î¿ÏÎ¹ÏƒÎ¼ÏŒÏ‚ Î¼ÎµÏ„Î±ÎºÎ¯Î½Î·ÏƒÎ·Ï‚
                this.relocateStartTime = 0;  // Î§ÏÏŒÎ½Î¿Ï‚ Î­Î½Î±ÏÎ¾Î·Ï‚ animation
                this.relocateStartPos = null;  // Î‘ÏÏ‡Î¹ÎºÎ® Î¸Î­ÏƒÎ· animation
                
                // Abilities System
                this.abilities = {
                    curveShot: 3  // Î£Î¿Ï…Ï„ Î¼Îµ Ï†Î¬Î»Ï„ÏƒÎ¿ - 3 Ï‡ÏÎ®ÏƒÎµÎ¹Ï‚ Î±Î½Î¬ Ï€Î±Î¹Ï‡Î½Î¯Î´Î¹
                };
                this.activeCurveShot = false;  // Flag Î³Î¹Î± ÎµÎ½ÎµÏÎ³ÏŒ curve shot
            }

            update() {
                // Animation Î¼ÎµÏ„Î±ÎºÎ¯Î½Î·ÏƒÎ·Ï‚ Î±Ï€ÏŒ Ï„Î­ÏÎ¼Î±
                if (this.isRelocating) {
                    const duration = 800;  // 0.8 Î´ÎµÏ…Ï„ÎµÏÏŒÎ»ÎµÏ€Ï„Î±
                    const elapsed = Date.now() - this.relocateStartTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Easing function - smooth in-out
                    const eased = progress < 0.5 
                        ? 2 * progress * progress 
                        : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                    
                    // Interpolation
                    this.x = this.relocateStartPos.x + (this.relocateTarget.x - this.relocateStartPos.x) * eased;
                    this.y = this.relocateStartPos.y + (this.relocateTarget.y - this.relocateStartPos.y) * eased;
                    
                    // Î¤Î­Î»Î¿Ï‚ animation
                    if (progress >= 1) {
                        this.x = this.relocateTarget.x;
                        this.y = this.relocateTarget.y;
                        this.isRelocating = false;
                        this.relocateTarget = null;
                    }
                    
                    return;  // Î”ÎµÎ½ ÎºÎ¬Î½Î¿Ï…Î¼Îµ ÎºÎ±Î½Î¿Î½Î¹ÎºÎ® ÎºÎ¯Î½Î·ÏƒÎ· ÏŒÏƒÎ¿ relocate
                }
                
                if (this.moving) {
                    this.x += this.vx;
                    this.y += this.vy;
                    
                    // Easing function Î³Î¹Î± Ï€Î±Î¯ÎºÏ„ÎµÏ‚ - Smooth exponential decay
                    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                    
                    if (speed > 0.5) {
                        // Î“ÏÎ±Î¼Î¼Î¹ÎºÎ® Î±Ï€ÏŒÏƒÎ²ÎµÏƒÎ· Î³Î¹Î± Î¿Î¼Î±Î»ÏŒÏ„ÎµÏÎ· ÎºÎ¯Î½Î·ÏƒÎ· (Î±Ï€ÏŒ 1.15)
                        const decayFactor = Math.pow(this.friction, 0.95);
                        this.vx *= decayFactor;
                        this.vy *= decayFactor;
                    } else {
                        // Î Î»Î®ÏÎ·Ï‚ ÏƒÏ„Î¬ÏƒÎ·
                        this.vx = 0;
                        this.vy = 0;
                        this.moving = false;
                    }

                    // Î£ÏÎ½Î¿ÏÎ± Î³Î·Ï€Î­Î´Î¿Ï… - ÎÎ­Î± ÏŒÏÎ¹Î± (20% Î¼Î¹ÎºÏÏŒÏ„ÎµÏÎ¿ Ï€Î»Î¬Ï„Î¿Ï‚)
                    const sideMargin = 240;  // Î‘Ï…Î¾Î·Î¼Î­Î½Î¿ Î±Ï€ÏŒ 80 (Ï€Î»ÎµÏ…ÏÎ¹ÎºÎ¬)
                    const topMargin = 180;
                    const bottomMargin = 80;  // ÎšÎ¬Ï„Ï‰ Ï€Î±ÏÎ±Î¼Î­Î½ÎµÎ¹ Ï„Î¿ Î¯Î´Î¹Î¿
                    
                    // ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ Î¿ÏÎ¯Ï‰Î½ - Î‘Î›Î›Î‘ ÎµÏ€Î¹Ï„ÏÎ­Ï€Î¿Ï…Î¼Îµ ÎµÎ¯ÏƒÎ¿Î´Î¿ ÏƒÏ„Î± Ï„Î­ÏÎ¼Î±Ï„Î±
                    const centerY = (topMargin + (canvas.height - bottomMargin)) / 2;
                    const goalHeight = 180;
                    const goalTop = centerY - (goalHeight / 2);
                    const goalBottom = centerY + (goalHeight / 2);
                    
                    // Î‘ÏÎ¹ÏƒÏ„ÎµÏÏŒ ÏŒÏÎ¹Î¿ - ÎµÎºÏ„ÏŒÏ‚ Î±Î½ ÎµÎ¯Î½Î±Î¹ Î¼Î­ÏƒÎ± ÏƒÏ„Î¿ Ï„Î­ÏÎ¼Î±
                    if (this.x - this.radius < sideMargin) {
                        if (this.y < goalTop || this.y > goalBottom) {
                            // Î•ÎºÏ„ÏŒÏ‚ Ï„Î­ÏÎ¼Î±Ï„Î¿Ï‚ - bounce
                            this.x = sideMargin + this.radius;
                            this.vx *= -0.5;
                        } else {
                            // ÎœÎ­ÏƒÎ± ÏƒÏ„Î¿ Ï„Î­ÏÎ¼Î± - ÏŒÏÎ¹Î¿ Ï€Î¯ÏƒÏ‰ Î³ÏÎ±Î¼Î¼Î®Ï‚
                            const goalDepth = 60;
                            const backLine = sideMargin - goalDepth;
                            if (this.x - this.radius < backLine) {
                                this.x = backLine + this.radius;
                                this.vx = 0;  // Î£Î¤Î‘Î£Î—
                                this.vy *= 0.7;
                            }
                            // ÎŒÏÎ¹Î± Ï€Î¬Î½Ï‰-ÎºÎ¬Ï„Ï‰ ÎœÎ•Î£Î‘ ÏƒÏ„Î¿ Ï„Î­ÏÎ¼Î± (Î´Î¿ÎºÎ¬ÏÎ¹Î±)
                            if (this.y - this.radius < goalTop) {
                                this.y = goalTop + this.radius;
                                this.vy = 0;
                            }
                            if (this.y + this.radius > goalBottom) {
                                this.y = goalBottom - this.radius;
                                this.vy = 0;
                            }
                        }
                    }
                    
                    // Î”ÎµÎ¾Î¯ ÏŒÏÎ¹Î¿ - ÎµÎºÏ„ÏŒÏ‚ Î±Î½ ÎµÎ¯Î½Î±Î¹ Î¼Î­ÏƒÎ± ÏƒÏ„Î¿ Ï„Î­ÏÎ¼Î±
                    if (this.x + this.radius > canvas.width - sideMargin) {
                        if (this.y < goalTop || this.y > goalBottom) {
                            // Î•ÎºÏ„ÏŒÏ‚ Ï„Î­ÏÎ¼Î±Ï„Î¿Ï‚ - bounce
                            this.x = canvas.width - sideMargin - this.radius;
                            this.vx *= -0.5;
                        } else {
                            // ÎœÎ­ÏƒÎ± ÏƒÏ„Î¿ Ï„Î­ÏÎ¼Î± - ÏŒÏÎ¹Î¿ Ï€Î¯ÏƒÏ‰ Î³ÏÎ±Î¼Î¼Î®Ï‚
                            const goalDepth = 60;
                            const backLine = canvas.width - sideMargin + goalDepth;
                            if (this.x + this.radius > backLine) {
                                this.x = backLine - this.radius;
                                this.vx = 0;  // Î£Î¤Î‘Î£Î—
                                this.vy *= 0.7;
                            }
                            // ÎŒÏÎ¹Î± Ï€Î¬Î½Ï‰-ÎºÎ¬Ï„Ï‰ ÎœÎ•Î£Î‘ ÏƒÏ„Î¿ Ï„Î­ÏÎ¼Î± (Î´Î¿ÎºÎ¬ÏÎ¹Î±)
                            if (this.y - this.radius < goalTop) {
                                this.y = goalTop + this.radius;
                                this.vy = 0;
                            }
                            if (this.y + this.radius > goalBottom) {
                                this.y = goalBottom - this.radius;
                                this.vy = 0;
                            }
                        }
                    }
                    
                    // Î Î¬Î½Ï‰-ÎºÎ¬Ï„Ï‰ ÏŒÏÎ¹Î± (ÎºÎ±Î½Î¿Î½Î¹ÎºÎ¬)
                    if (this.y - this.radius < topMargin) {
                        this.y = topMargin + this.radius;
                        this.vy *= -0.5;
                    }
                    if (this.y + this.radius > canvas.height - bottomMargin) {
                        this.y = canvas.height - bottomMargin - this.radius;
                        this.vy *= -0.5;
                    }
                }
            }

            checkPlayerCollision(otherPlayer) {
                // Collision Î¼ÎµÏ„Î±Î¾Ï Ï€Î±Î¹ÎºÏ„ÏÎ½
                const dx = otherPlayer.x - this.x;
                const dy = otherPlayer.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const minDist = this.radius + otherPlayer.radius;

                if (distance < minDist && distance > 0) {
                    // ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ cooldown - Î±Î½ Î¼ÏŒÎ»Î¹Ï‚ Ï‡Ï„ÏÏ€Î·ÏƒÎ±Î½, Î¼Î·Î½ Ï„Î¿ Î¾Î±Î½Î±ÎºÎ¬Î½ÎµÎ¹Ï‚ Î±Î¼Î­ÏƒÏ‰Ï‚
                    const otherId = otherPlayer.x + '_' + otherPlayer.y;  // Unique ID
                    if (this.collisionCooldown[otherId] && Date.now() - this.collisionCooldown[otherId] < 100) {
                        return;  // Î ÎµÏÎ¯Î¼ÎµÎ½Îµ Î»Î¯Î³Î¿ Ï€ÏÎ¹Î½ Ï„Î·Î½ ÎµÏ€ÏŒÎ¼ÎµÎ½Î· collision
                    }
                    this.collisionCooldown[otherId] = Date.now();
                    
                    // Î¥Ï€Î¿Î»Î¿Î³Î¹ÏƒÎ¼ÏŒÏ‚ Î³Ï‰Î½Î¯Î±Ï‚ ÏƒÏÎ³ÎºÏÎ¿Ï…ÏƒÎ·Ï‚
                    const angle = Math.atan2(dy, dx);
                    const overlap = minDist - distance;
                    
                    // Î‘ÎœÎ•Î£ÎŸÎ£ ÎºÎ±Î¹ Î Î›Î—Î¡Î—Î£ Ï‡Ï‰ÏÎ¹ÏƒÎ¼ÏŒÏ‚ - Î¼Îµ Ï€Î±ÏÎ±Ï€Î¬Î½Ï‰ Î±Ï€ÏŒÏƒÏ„Î±ÏƒÎ·
                    const separation = overlap + 2;  // +2 Î³Î¹Î± Î½Î± ÏƒÎ¹Î³Î¿Ï…ÏÎµÏ…Ï„Î¿ÏÎ¼Îµ ÏŒÏ„Î¹ Î´ÎµÎ½ ÎµÏ€Î¹ÎºÎ±Î»ÏÏ€Ï„Î¿Î½Ï„Î±Î¹
                    const pushX = Math.cos(angle) * separation / 2;
                    const pushY = Math.sin(angle) * separation / 2;
                    
                    this.x -= pushX;
                    this.y -= pushY;
                    otherPlayer.x += pushX;
                    otherPlayer.y += pushY;
                    
                    // ÎœÎµÏ„Î±Ï†Î¿ÏÎ¬ ÎµÎ½Î­ÏÎ³ÎµÎ¹Î±Ï‚ (Î¿ÏÎ¼Î®Ï‚) ÏƒÎ±Î½ Î¼Ï€Î¹Î»Î¹Î¬ÏÎ´Î¿
                    // Î¥Ï€Î¿Î»Î¿Î³Î¹ÏƒÎ¼ÏŒÏ‚ ÏƒÏ‡ÎµÏ„Î¹ÎºÎ®Ï‚ Ï„Î±Ï‡ÏÏ„Î·Ï„Î±Ï‚
                    const relVx = this.vx - otherPlayer.vx;
                    const relVy = this.vy - otherPlayer.vy;
                    
                    // Î ÏÎ¿Î²Î¿Î»Î® Ï„Î·Ï‚ ÏƒÏ‡ÎµÏ„Î¹ÎºÎ®Ï‚ Ï„Î±Ï‡ÏÏ„Î·Ï„Î±Ï‚ ÏƒÏ„Î· Î³ÏÎ±Î¼Î¼Î® ÏƒÏÎ³ÎºÏÎ¿Ï…ÏƒÎ·Ï‚
                    const relVelocityDotNormal = relVx * Math.cos(angle) + relVy * Math.sin(angle);
                    
                    // Î‘Î½ Î±Ï€Î¿Î¼Î±ÎºÏÏÎ½Î¿Î½Ï„Î±Î¹ Î®Î´Î·, Î¼Î·Î½ ÎºÎ¬Î½ÎµÎ¹Ï‚ Ï„Î¯Ï€Î¿Ï„Î± Î¼Îµ Ï„Î·Î½ Ï„Î±Ï‡ÏÏ„Î·Ï„Î±
                    if (relVelocityDotNormal > 0) return;
                    
                    // Î£Ï…Î½Ï„ÎµÎ»ÎµÏƒÏ„Î®Ï‚ ÎµÎ»Î±ÏƒÏ„Î¹ÎºÏŒÏ„Î·Ï„Î±Ï‚ (0.85 = Î»Î¯Î³Î· Î±Ï€ÏÎ»ÎµÎ¹Î± ÎµÎ½Î­ÏÎ³ÎµÎ¹Î±Ï‚, Ï€Î¹Î¿ ÏÎµÎ±Î»Î¹ÏƒÏ„Î¹ÎºÏŒ)
                    const restitution = 0.85;
                    
                    // Î¥Ï€Î¿Î»Î¿Î³Î¹ÏƒÎ¼ÏŒÏ‚ impulse (ÏÎ¸Î·ÏƒÎ·Ï‚)
                    const impulse = -(1 + restitution) * relVelocityDotNormal / 2;
                    
                    // Î•Ï†Î±ÏÎ¼Î¿Î³Î® impulse
                    const impulseX = impulse * Math.cos(angle);
                    const impulseY = impulse * Math.sin(angle);
                    
                    this.vx -= impulseX;
                    this.vy -= impulseY;
                    otherPlayer.vx += impulseX;
                    otherPlayer.vy += impulseY;
                    
                    // Î‘Î½ ÎºÎ¬Ï€Î¿Î¹Î¿Ï‚ Ï€Î±Î¯ÎºÏ„Î·Ï‚ Î´ÎµÎ½ ÎºÎ¹Î½Î¿ÏÎ½Ï„Î±Î½, Ï„ÏÏÎ± ÎºÎ¹Î½ÎµÎ¯Ï„Î±Î¹
                    if (!this.moving && (Math.abs(this.vx) > 0.5 || Math.abs(this.vy) > 0.5)) {
                        this.moving = true;
                    }
                    if (!otherPlayer.moving && (Math.abs(otherPlayer.vx) > 0.5 || Math.abs(otherPlayer.vy) > 0.5)) {
                        otherPlayer.moving = true;
                    }
                }
            }

            draw() {
                // Î”Î±ÎºÏ„ÏÎ»Î¹Î¿Ï‚ Î±Î½ ÎµÏ€Î¹Î»ÎµÎ³Î¼Î­Î½Î¿Ï‚
                if (this.selected) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + 8, 0, Math.PI * 2);
                    ctx.strokeStyle = '#FFD700';  // Î§ÏÏ…ÏƒÏŒ Î³Î¹Î± highlight
                    ctx.lineWidth = 5;
                    ctx.stroke();
                }

                // Î£Ï‡ÎµÎ´Î¯Î±ÏƒÎ· ÎµÎ¹ÎºÏŒÎ½Î±Ï‚ duck - Î‘ÎÎ¤Î™Î£Î¤Î¡ÎŸÎ¦Î‘!
                // ÎšÏŒÎºÎºÎ¹Î½Î¿Î¹ Ï€Î±Î¯ÎºÏ„ÎµÏ‚ (YOU) â†’ ÎœÏ€Î»Îµ Ï€Î¬Ï€Î¹Î±
                // ÎœÏ€Î»Îµ Ï€Î±Î¯ÎºÏ„ÎµÏ‚ (BOT) â†’ ÎšÏŒÎºÎºÎ¹Î½Î± Ï€Î¬Ï€Î¹Î±
                const image = this.isBot ? images.duckRed : images.duckBlue;
                const size = this.radius * 2;  // Î”Î¹Î¬Î¼ÎµÏ„ÏÎ¿Ï‚
                
                // Fallback: Î‘Î½ Î· ÎµÎ¹ÎºÏŒÎ½Î± Î´ÎµÎ½ Î­Ï‡ÎµÎ¹ Ï†Î¿ÏÏ„ÏÏƒÎµÎ¹, ÏƒÏ‡ÎµÎ´Î¯Î±ÏƒÎµ Ï‡ÏÏ‰Î¼Î±Ï„Î¹ÏƒÏ„ÏŒ ÎºÏÎºÎ»Î¿
                if (image.complete && image.naturalWidth > 0) {
                    ctx.drawImage(
                        image,
                        this.x - this.radius,  // ÎšÎ­Î½Ï„ÏÎ¿ - Î±ÎºÏ„Î¯Î½Î±
                        this.y - this.radius,
                        size,
                        size
                    );
                } else {
                    // Fallback: Î£Ï‡ÎµÎ´Î¯Î±ÏƒÎµ Ï‡ÏÏ‰Î¼Î±Ï„Î¹ÏƒÏ„ÏŒ ÎºÏÎºÎ»Î¿
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = this.isBot ? '#ff3420' : '#2745e1';
                    ctx.fill();
                    ctx.strokeStyle = COLORS.white;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            }

            checkCollision(ball) {
                const dx = ball.x - this.x;
                const dy = ball.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const minDistance = this.radius + ball.radius;

                if (distance < minDistance && distance > 0) {
                    // Cooldown Î³Î¹Î± Î½Î± Î¼Î·Î½ Ï‡Ï„Ï…Ï€Î¬ÎµÎ¹ ÏƒÏ…Î½Î­Ï‡ÎµÎ¹Î± Ï„Î·Î½ Î¯Î´Î¹Î± Î¼Ï€Î¬Î»Î±
                    if (Date.now() - this.ballCollisionTime < 30) {  // ÎœÎµÎ¹ÏÎ¸Î·ÎºÎµ Î±Ï€ÏŒ 50 ÏƒÎµ 30
                        return;  // Î ÎµÏÎ¯Î¼ÎµÎ½Îµ 30ms Ï€ÏÎ¹Î½ Ï„Î¿ ÎµÏ€ÏŒÎ¼ÎµÎ½Î¿ Ï‡Ï„ÏÏ€Î·Î¼Î±
                    }
                    this.ballCollisionTime = Date.now();
                    
                    const angle = Math.atan2(dy, dx);
                    const overlap = minDistance - distance;
                    
                    // Î Î¡Î©Î¤Î‘ Ï‡Ï‰ÏÎ¯Î¶Î¿Ï…Î¼Îµ Ï„Î· Î¼Ï€Î¬Î»Î± Î±Ï€ÏŒ Ï„Î¿Î½ Ï€Î±Î¯ÎºÏ„Î· Î¼Îµ Î±ÎºÏŒÎ¼Î± Î¼ÎµÎ³Î±Î»ÏÏ„ÎµÏÎ· Î±Ï€ÏŒÏƒÏ„Î±ÏƒÎ·
                    const separationMultiplier = 1.2;  // Î‘Ï…Î¾Î·Î¼Î­Î½Î¿ Î±Ï€ÏŒ 1.1 ÏƒÎµ 1.2
                    ball.x += Math.cos(angle) * (overlap * separationMultiplier + 3);  // +3 pixels extra
                    ball.y += Math.sin(angle) * (overlap * separationMultiplier + 3);
                    
                    // ÎœÎµÏ„Î±Ï†Î¿ÏÎ¬ Î¿ÏÎ¼Î®Ï‚ Î±Ï€ÏŒ Ï€Î±Î¯ÎºÏ„Î· ÏƒÎµ Î¼Ï€Î¬Î»Î± (impulse-based physics)
                    const relativeVx = this.vx - ball.vx;
                    const relativeVy = this.vy - ball.vy;
                    
                    // Î ÏÎ¿Î²Î¿Î»Î® Ï„Î·Ï‚ ÏƒÏ‡ÎµÏ„Î¹ÎºÎ®Ï‚ Ï„Î±Ï‡ÏÏ„Î·Ï„Î±Ï‚ ÏƒÏ„Î· Î³ÏÎ±Î¼Î¼Î® ÏƒÏÎ³ÎºÏÎ¿Ï…ÏƒÎ·Ï‚
                    const relVelocityDotNormal = relativeVx * Math.cos(angle) + relativeVy * Math.sin(angle);
                    
                    // Î‘Î½ Î±Ï€Î¿Î¼Î±ÎºÏÏÎ½Î¿Î½Ï„Î±Î¹ Î®Î´Î·, Î¼Î·Î½ ÎºÎ¬Î½ÎµÎ¹Ï‚ Ï„Î¯Ï€Î¿Ï„Î±
                    if (relVelocityDotNormal < 0) return;
                    
                    // Î£Ï…Î½Ï„ÎµÎ»ÎµÏƒÏ„Î®Ï‚ ÎµÎ»Î±ÏƒÏ„Î¹ÎºÏŒÏ„Î·Ï„Î±Ï‚ ÎºÎ±Î¹ Î¼ÎµÏ„Î±Ï†Î¿ÏÎ¬ Î¼Î¬Î¶Î±Ï‚
                    const restitution = 0.9;  // Î›Î¯Î³Î· Î±Ï€ÏÎ»ÎµÎ¹Î± ÎµÎ½Î­ÏÎ³ÎµÎ¹Î±Ï‚
                    const massRatio = 0.8;  // ÎŸ Ï€Î±Î¯ÎºÏ„Î·Ï‚ ÎµÎ¯Î½Î±Î¹ Î²Î±ÏÏÏ„ÎµÏÎ¿Ï‚, Î¬ÏÎ± Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎ· Î¼ÎµÏ„Î±Ï†Î¿ÏÎ¬
                    
                    // Î¥Ï€Î¿Î»Î¿Î³Î¹ÏƒÎ¼ÏŒÏ‚ impulse
                    const impulse = (1 + restitution) * relVelocityDotNormal * massRatio;
                    
                    // Î•Ï†Î±ÏÎ¼Î¿Î³Î® impulse ÏƒÏ„Î· Î¼Ï€Î¬Î»Î±
                    ball.vx += Math.cos(angle) * impulse;
                    ball.vy += Math.sin(angle) * impulse;
                    
                    // Î‘Î½ Î¿ Ï€Î±Î¯ÎºÏ„Î·Ï‚ Î­Ï‡ÎµÎ¹ ÎµÎ½ÎµÏÎ³Î¿Ï€Î¿Î¹Î®ÏƒÎµÎ¹ Ï„Î¿ Curve Shot
                    if (this.activeCurveShot && this.pendingCurve) {
                        // Î§ÏÎ®ÏƒÎ· Ï„Î¿Ï… custom curve Ï€Î¿Ï… ÏŒÏÎ¹ÏƒÎµ Î¿ Ï€Î±Î¯ÎºÏ„Î·Ï‚
                        const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                        const curveStrength = this.pendingCurve.strength;
                        const curveDirX = this.pendingCurve.directionX;
                        const curveDirY = this.pendingCurve.directionY;
                        
                        // Î•Ï†Î±ÏÎ¼Î¿Î³Î® curve force ÏƒÏ„Î·Î½ ÎºÎ±Ï„ÎµÏÎ¸Ï…Î½ÏƒÎ· Ï€Î¿Ï… ÏŒÏÎ¹ÏƒÎµ Î¿ Ï€Î±Î¯ÎºÏ„Î·Ï‚
                        ball.curveForce = speed * curveStrength * 0.2;
                        ball.curveDirectionX = curveDirX;
                        ball.curveDirectionY = curveDirY;
                        
                        // Î‘Ï€ÎµÎ½ÎµÏÎ³Î¿Ï€Î¿Î¯Î·ÏƒÎ· Ï„Î¿Ï… ability
                        this.activeCurveShot = false;
                        this.pendingCurve = null;
                        this.abilities.curveShot--;
                        
                        console.log(`ğŸŒ€ Curve Shot with custom direction! Strength: ${curveStrength.toFixed(2)}, Remaining: ${this.abilities.curveShot}`);
                    } else if (this.activeCurveShot) {
                        // Fallback: Î‘Ï…Ï„ÏŒÎ¼Î±Ï„Î¿ curve (Î±Î½ Î´ÎµÎ½ Î­Î³Î¹Î½Îµ adjustment)
                        const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                        ball.curveForce = speed * 0.15;
                        
                        this.activeCurveShot = false;
                        this.abilities.curveShot--;
                        
                        console.log(`ğŸŒ€ Curve Shot (auto)! Remaining: ${this.abilities.curveShot}`);
                    }
                }
            }

            isClicked(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                return Math.sqrt(dx * dx + dy * dy) <= this.radius;
            }

            shoot(dragX, dragY) {
                // Î‘Î½Ï„Î¯ÏƒÏ„ÏÎ¿Ï†Î· ÎºÎ±Ï„ÎµÏÎ¸Ï…Î½ÏƒÎ· (slingshot)
                const maxDragDistance = 200; // ÎœÎ­Î³Î¹ÏƒÏ„Î· Î±Ï€ÏŒÏƒÏ„Î±ÏƒÎ· Î³Î¹Î± full power (ÏƒÏ…Î½Ï„Î¿Î¼ÏŒÏ„ÎµÏÎ· ÎºÎ»Î¯Î¼Î±ÎºÎ±)
                const dragDistance = Math.sqrt(dragX * dragX + dragY * dragY);
                
                console.log('Shooting with drag distance:', dragDistance);
                
                // Î¥Ï€Î¿Î»Î¿Î³Î¹ÏƒÎ¼ÏŒÏ‚ power (0 Î­Ï‰Ï‚ 1) - Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯ Ï„Î¿ ORIGINAL drag distance
                const power = Math.min(dragDistance / maxDragDistance, 1.0); // Capped at 1.0
                
                // ÎšÎ±Î½Î¿Î½Î¹ÎºÎ¿Ï€Î¿Î¯Î·ÏƒÎ· ÎºÎ±Ï„ÎµÏÎ¸Ï…Î½ÏƒÎ·Ï‚ (unit vector)
                const dirX = dragDistance > 0 ? dragX / dragDistance : 0;
                const dirY = dragDistance > 0 ? dragY / dragDistance : 0;
                
                // ÎœÎ­Î³Î¹ÏƒÏ„Î· Ï„Î±Ï‡ÏÏ„Î·Ï„Î±
                const maxSpeed = 25;
                
                // Î•Ï†Î±ÏÎ¼Î¿Î³Î® Ï„Î±Ï‡ÏÏ„Î·Ï„Î±Ï‚: ÎºÎ±Ï„ÎµÏÎ¸Ï…Î½ÏƒÎ· * power * maxSpeed
                this.vx = -dirX * power * maxSpeed;
                this.vy = -dirY * power * maxSpeed;
                
                console.log('Power:', power, 'Velocities:', this.vx, this.vy);
                
                this.moving = true;
            }
        }

        // Î Î±Î¹Ï‡Î½Î¯Î´Î¹
        // ====================================
        // CROWD SYSTEM - Animated Spectators
        // ====================================
        class CrowdSystem {
            constructor(fieldMargins) {
                this.spectators = [];
                this.time = 0;
                this.fieldMargins = fieldMargins; // { sideMargin, topMargin, bottomMargin, borderWidth }
                
                // Configuration
                this.spectatorRadius = 20; // HUGE for testing (was 12)
                this.spectatorSpacing = 30; // Increased from 25
                this.waveAmplitude = 10; // Increased from 5
                this.waveSpeed = 0.005; // Faster
                
                // Colors for variety
                this.spectatorColors = [
                    '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', 
                    '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2'
                ];
                
                this.initializeSpectators();
            }
            
            initializeSpectators() {
                const { sideMargin, topMargin, bottomMargin, borderWidth } = this.fieldMargins;
                const fieldWidth = canvas.width - (sideMargin * 2);
                const fieldHeight = canvas.height - topMargin - bottomMargin;
                
                // Define crowd zones (CLOSER to field for visibility)
                const crowdDepth = 25; // Reduced from 40
                const standOffset = borderWidth + 5; // Reduced from 10
                
                // Top stand
                this.createStandRow(
                    sideMargin - standOffset, 
                    topMargin - standOffset - crowdDepth,
                    fieldWidth + (standOffset * 2),
                    'horizontal'
                );
                
                // Bottom stand
                this.createStandRow(
                    sideMargin - standOffset,
                    canvas.height - bottomMargin + standOffset,
                    fieldWidth + (standOffset * 2),
                    'horizontal'
                );
                
                // Left stand
                this.createStandRow(
                    sideMargin - standOffset - crowdDepth,
                    topMargin - standOffset,
                    fieldHeight + (standOffset * 2),
                    'vertical'
                );
                
                // Right stand
                this.createStandRow(
                    canvas.width - sideMargin + standOffset,
                    topMargin - standOffset,
                    fieldHeight + (standOffset * 2),
                    'vertical'
                );
                
                console.log(`ğŸ¦† Crowd system initialized with ${this.spectators.length} spectators`);
                if (this.spectators.length > 0) {
                    console.log(`First spectator at: x=${this.spectators[0].x.toFixed(0)}, y=${this.spectators[0].y.toFixed(0)}`);
                    console.log(`Canvas size: ${canvas.width} x ${canvas.height}`);
                }
            }
            
            createStandRow(startX, startY, length, orientation) {
                const count = Math.floor(length / this.spectatorSpacing);
                
                for (let i = 0; i < count; i++) {
                    const position = i * this.spectatorSpacing + (this.spectatorSpacing / 2);
                    const randomOffset = (Math.random() - 0.5) * 10; // Add some variation
                    
                    let x, y;
                    if (orientation === 'horizontal') {
                        x = startX + position + randomOffset;
                        y = startY;
                    } else {
                        x = startX;
                        y = startY + position + randomOffset;
                    }
                    
                    this.spectators.push({
                        x: x,
                        y: y,
                        baseY: y, // Store original y for wave animation
                        phase: Math.random() * Math.PI * 2, // Random phase for wave
                        color: this.spectatorColors[Math.floor(Math.random() * this.spectatorColors.length)],
                        radius: this.spectatorRadius + (Math.random() - 0.5) * 2 // Slight size variation
                    });
                }
            }
            
            update(deltaTime) {
                // Update time for wave animation
                this.time += deltaTime || 16; // Default 16ms if no deltaTime
            }
            
            draw() {
                // Debug: Log first time
                if (!this.hasLogged && this.spectators.length > 0) {
                    console.log('ğŸ¨ Drawing crowd:', this.spectators.length, 'spectators');
                    console.log('First spectator:', this.spectators[0]);
                    this.hasLogged = true;
                }
                
                ctx.save();
                
                // Draw spectators with wave animation
                this.spectators.forEach(spectator => {
                    // Calculate wave offset
                    const waveOffset = Math.sin(this.time * this.waveSpeed + spectator.phase) * this.waveAmplitude;
                    const currentY = spectator.baseY + waveOffset;
                    
                    // Draw spectator head (VERY VISIBLE for testing)
                    ctx.beginPath();
                    ctx.arc(spectator.x, currentY, spectator.radius, 0, Math.PI * 2);
                    ctx.fillStyle = spectator.color;
                    ctx.fill();
                    
                    // Add visible outline for contrast against black background
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                });
                
                ctx.restore();
            }
        }

        // ====================================
        // END CROWD SYSTEM
        // ====================================

        class Game {
            constructor() {
                this.isMultiplayer = isMultiplayer;
                this.isLocal1v1 = isLocal1v1;  // ğŸ‘¥ Local 1v1 flag
                this.isHost = isHost;
                this.myTeam = this.isHost ? 'player' : 'bot';  // Host = ÎºÏŒÎºÎºÎ¹Î½Î±, Guest = Î¼Ï€Î»Îµ
                
                this.ball = new Ball();
                this.playerScore = 0;
                this.botScore = 0;
                this.currentTurn = 'player'; // 'player' Î® 'bot'
                this.turnComplete = true;
                this.goalMessage = null;  // ÎœÎ®Î½Ï…Î¼Î± Î³ÎºÎ¿Î»
                this.goalMessageTime = 0;  // Î§ÏÏŒÎ½Î¿Ï‚ ÎµÎ¼Ï†Î¬Î½Î¹ÏƒÎ·Ï‚ Î¼Î·Î½ÏÎ¼Î±Ï„Î¿Ï‚
                
                // Î”Î¿ÎºÎ¬ÏÎ¹Î± Ï„ÎµÏÎ¼Î¬Ï„Ï‰Î½
                const margin = 240;
                const topMargin = 180;
                const centerY = (topMargin + (canvas.height - 80)) / 2;
                
                this.goalPosts = [
                    // Î‘ÏÎ¹ÏƒÏ„ÎµÏÏŒ Ï„Î­ÏÎ¼Î±
                    { x: margin, y: centerY - 90, radius: 8 },  // Î Î¬Î½Ï‰
                    { x: margin, y: centerY + 90, radius: 8 },  // ÎšÎ¬Ï„Ï‰
                    // Î”ÎµÎ¾Î¯ Ï„Î­ÏÎ¼Î±
                    { x: canvas.width - margin, y: centerY - 90, radius: 8 },  // Î Î¬Î½Ï‰
                    { x: canvas.width - margin, y: centerY + 90, radius: 8 }   // ÎšÎ¬Ï„Ï‰
                ];
                
                // ğŸ¦† Initialize Crowd System
                this.crowdSystem = new CrowdSystem({
                    sideMargin: 240,
                    topMargin: 180,
                    bottomMargin: 80,
                    borderWidth: 45
                });
                
                // Î‘ÏÏ‡Î¹ÎºÎ­Ï‚ Î¸Î­ÏƒÎµÎ¹Ï‚ Ï€Î±Î¹ÎºÏ„ÏÎ½ - ÎŸÏÎ¹Î¶ÏŒÎ½Ï„Î¹Î¿ Î³Î®Ï€ÎµÎ´Î¿
                
                this.initialPositions = {
                    player: [
                        { x: margin + 150, y: centerY - 180 },
                        { x: margin + 150, y: centerY + 180 },
                        { x: margin + 280, y: centerY - 100 },
                        { x: margin + 100, y: centerY },
                        { x: margin + 280, y: centerY + 100 }
                    ],
                    bot: [
                        { x: canvas.width - margin - 150, y: centerY - 180 },
                        { x: canvas.width - margin - 150, y: centerY + 180 },
                        { x: canvas.width - margin - 280, y: centerY - 100 },
                        { x: canvas.width - margin - 100, y: centerY },
                        { x: canvas.width - margin - 280, y: centerY + 100 }
                    ]
                };
                
                // Î Î±Î¯ÎºÏ„ÎµÏ‚ (ÎºÏŒÎºÎºÎ¹Î½Î¿Î¹ - ÎºÎ¬Ï„Ï‰)
                this.playerTeam = this.initialPositions.player.map(pos => 
                    new Player(pos.x, pos.y, COLORS.red)
                );

                // Bot (Î¼Ï€Î»Îµ - Ï€Î¬Î½Ï‰)
                this.botTeam = this.initialPositions.bot.map(pos => 
                    new Player(pos.x, pos.y, COLORS.blue, true)
                );

                this.selectedPlayer = null;
                this.dragStart = null;
                this.currentDrag = null;
                this.setupEvents();
            }

            setupEvents() {
                canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
                canvas.addEventListener('touchstart', (e) => this.onTouchStart(e));
                canvas.addEventListener('touchmove', (e) => this.onTouchMove(e));
                canvas.addEventListener('touchend', (e) => this.onTouchEnd(e));
                
                // Back to Menu button listener
                document.getElementById('backToMenuBtn').addEventListener('click', backToMenu);
            }

            getMousePos(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }

            onMouseDown(e) {
                // Î£Ï„Î¿ multiplayer, Î­Î»ÎµÎ³Ï‡Î¿Ï‚ Î±Î½ ÎµÎ¯Î½Î±Î¹ Î· Î´Î¹ÎºÎ® ÏƒÎ¿Ï… Î¿Î¼Î¬Î´Î±
                if (this.isMultiplayer) {
                    if (this.currentTurn !== this.myTeam) return;
                } else if (this.isLocal1v1) {
                    // ğŸ‘¥ Local 1v1: ÎšÎ±Î¹ Î¿Î¹ Î´ÏÎ¿ Ï€Î±Î¯ÎºÏ„ÎµÏ‚ Î¼Ï€Î¿ÏÎ¿ÏÎ½ Î½Î± Ï€Î±Î¯Î¾Î¿Ï…Î½
                    // Î”ÎµÎ½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Ï€ÎµÏÎ¹Î¿ÏÎ¹ÏƒÎ¼ÏŒÏ‚ - ÎµÎ»Î­Î³Ï‡Î¿Ï…Î¼Îµ Î¼ÏŒÎ½Î¿ Î±Î½ ÎµÎ¯Î½Î±Î¹ Î· ÏƒÎµÎ¹ÏÎ¬ ÎºÎ¬Ï€Î¿Î¹Î¿Ï…
                } else {
                    // Local game vs bot - Î¼ÏŒÎ½Î¿ player
                    if (this.currentTurn !== 'player') return;
                }
                
                if (!this.turnComplete) return;

                const pos = this.getMousePos(e);
                console.log('Mouse down at:', pos.x, pos.y);

                // ğŸ‘¥ Local 1v1: Î”Î¹Î¬Î»ÎµÎ¾Îµ Î±Ï€ÏŒ Ï„Î·Î½ Î¿Î¼Î¬Î´Î± Ï€Î¿Ï… Î­Ï‡ÎµÎ¹ ÏƒÎµÎ¹ÏÎ¬
                let team;
                if (this.isLocal1v1) {
                    // Î£Ï„Î¿ local 1v1, ÎµÏ€Î¹Ï„ÏÎ­Ï€Î¿Ï…Î¼Îµ ÎµÏ€Î¹Î»Î¿Î³Î® Î±Ï€ÏŒ Ï„Î·Î½ Î¿Î¼Î¬Î´Î± Ï€Î¿Ï… Î­Ï‡ÎµÎ¹ Ï„Î· ÏƒÎµÎ¹ÏÎ¬
                    team = this.currentTurn === 'player' ? this.playerTeam : this.botTeam;
                } else if (this.isMultiplayer && this.myTeam === 'bot') {
                    team = this.botTeam;
                } else {
                    team = this.playerTeam;
                }
                
                for (let player of team) {
                    if (player.isClicked(pos.x, pos.y)) {
                        this.selectedPlayer = player;
                        player.selected = true;
                        this.dragStart = { x: player.x, y: player.y };
                        updateAbilitiesUI(); // Update UI when player is selected
                        console.log('Selected player at:', player.x, player.y);
                        break;
                    }
                }
            }

            onMouseMove(e) {
                if (this.selectedPlayer && this.dragStart) {
                    const pos = this.getMousePos(e);
                    this.currentDrag = pos;
                }
            }

            onMouseUp(e) {
                if (this.selectedPlayer && this.dragStart) {
                    // Î‘Î½ Î´ÎµÎ½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ valid position (Ï€Ï‡ touch Ï€Î¿Ï… Î´ÎµÎ½ Î­Ï‡ÎµÎ¹ clientX/Y),
                    // Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¯Î·ÏƒÎµ Ï„Î¿ Ï„ÎµÎ»ÎµÏ…Ï„Î±Î¯Î¿ currentDrag position
                    let pos;
                    if (e && e.clientX !== undefined && e.clientY !== undefined) {
                        pos = this.getMousePos(e);
                    } else if (this.currentDrag) {
                        pos = this.currentDrag;
                    } else {
                        pos = this.dragStart;
                    }
                    
                    const dragX = pos.x - this.dragStart.x;
                    const dragY = pos.y - this.dragStart.y;
                    
                    console.log('Drag values:', dragX, dragY, 'Distance:', Math.sqrt(dragX*dragX + dragY*dragY));
                    
                    // ğŸ”„ ÎšÎ‘Î›Î¥Î¤Î•Î¡ÎŸÎ£ Î¤Î¡ÎŸÎ ÎŸÎ£ Î‘ÎšÎ¥Î¡Î©Î£Î—Î£: ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ Î±Î½ Î¿ ÎºÎ­ÏÏƒÎ¿ÏÎ±Ï‚/Î´Î¬Ï‡Ï„Ï…Î»Î¿ ÎµÎ¯Î½Î±Î¹ Ï€Î¬Î½Ï‰ ÏƒÏ„Î¿Î½ Ï€Î±Î¯ÎºÏ„Î·
                    const distanceFromPlayer = Math.sqrt(
                        (pos.x - this.selectedPlayer.x) ** 2 + 
                        (pos.y - this.selectedPlayer.y) ** 2
                    );
                    const playerRadius = this.selectedPlayer.radius;
                    
                    // Î‘Î½ Î¿ ÎºÎ­ÏÏƒÎ¿ÏÎ±Ï‚ ÎµÎ¯Î½Î±Î¹ Î¼Î­ÏƒÎ± ÏƒÏ„Î¿Î½ ÎºÏÎºÎ»Î¿ Ï„Î¿Ï… Ï€Î±Î¯ÎºÏ„Î· â†’ Î‘ÎšÎ¥Î¡Î©Î£Î—!
                    if (distanceFromPlayer <= playerRadius * 0.9) { // 0.9x Î³Î¹Î± Ï€Î¹Î¿ ÏƒÏ„ÎµÎ½Î® cancel zone (Î¼Î¹ÎºÏÏÏ„ÎµÏÎ¿ Î±Ï€ÏŒ 1.5 Î³Î¹Î± Î¼ÎµÎ³Î¬Î»Î¿ drag)
                        console.log('âŒ Shot CANCELLED! Cursor returned to player. Distance:', distanceFromPlayer.toFixed(1), 'â‰¤', (playerRadius * 1.5).toFixed(1));
                        
                        // Visual feedback: Flash effect before deselect
                        const deselectedPlayer = this.selectedPlayer;
                        deselectedPlayer.selected = false;
                        
                        // Brief red flash to show cancellation
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(deselectedPlayer.x, deselectedPlayer.y, deselectedPlayer.radius + 12, 0, Math.PI * 2);
                        ctx.strokeStyle = '#FF0000';  // Red Î³Î¹Î± cancel
                        ctx.lineWidth = 6;
                        ctx.stroke();
                        ctx.restore();
                        
                        this.selectedPlayer = null;
                        this.dragStart = null;
                        this.currentDrag = null;
                        return; // Return Ï‡Ï‰ÏÎ¯Ï‚ shoot - Î¼Ï€Î¿ÏÎµÎ¯Ï‚ Î½Î± ÎºÎ¬Î½ÎµÎ¹Ï‚ Î¬Î»Î»Î¿ click!
                    }
                    
                    // Î”ÎµÏ…Ï„ÎµÏÎµÏÏ‰Î½ Î­Î»ÎµÎ³Ï‡Î¿Ï‚: Î Î¿Î»Ï Î¼Î¹ÎºÏÏŒ drag (fallback)
                    const dragDistance = Math.sqrt(dragX * dragX + dragY * dragY);
                    const cancelThreshold = 20;
                    
                    if (dragDistance < cancelThreshold) {
                        console.log('âŒ Shot CANCELLED! Minimal drag:', dragDistance, '< threshold:', cancelThreshold);
                        
                        // Visual feedback: Flash effect before deselect
                        const deselectedPlayer = this.selectedPlayer;
                        deselectedPlayer.selected = false;
                        
                        // Brief red flash to show cancellation
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(deselectedPlayer.x, deselectedPlayer.y, deselectedPlayer.radius + 12, 0, Math.PI * 2);
                        ctx.strokeStyle = '#FF0000';  // Red Î³Î¹Î± cancel
                        ctx.lineWidth = 6;
                        ctx.stroke();
                        ctx.restore();
                        
                        this.selectedPlayer = null;
                        this.dragStart = null;
                        this.currentDrag = null;
                        return; // Return Ï‡Ï‰ÏÎ¯Ï‚ shoot - Î¼Ï€Î¿ÏÎµÎ¯Ï‚ Î½Î± ÎºÎ¬Î½ÎµÎ¹Ï‚ Î¬Î»Î»Î¿ click!
                    }
                    
                    // âœ… VALID DRAG - Proceed with shot
                    
                    // ÎšÎ±Î½Î¿Î½Î¹ÎºÏŒ shot
                    this.selectedPlayer.shoot(dragX, dragY);
                    
                    // Î£Ï„ÎµÎ¯Î»Îµ Ï„Î¿ shot ÏƒÏ„Î¿ Firebase Î±Î½ ÎµÎ¯Î½Î±Î¹ multiplayer
                    if (this.isMultiplayer && currentRoomId) {
                        const playerIndex = (this.myTeam === 'player' ? this.playerTeam : this.botTeam)
                            .indexOf(this.selectedPlayer);
                        
                        database.ref('rooms/' + currentRoomId + '/lastShot').set({
                            team: this.myTeam,
                            playerIndex: playerIndex,
                            dragX: dragX,
                            dragY: dragY,
                            timestamp: Date.now()
                        });
                    }
                    
                    // ÎÎµÎºÎ¹Î½Î¬ÎµÎ¹ Î· ÏƒÎµÎ¹ÏÎ¬
                    this.turnComplete = false;
                    
                    this.selectedPlayer.selected = false;
                    this.selectedPlayer = null;
                    this.dragStart = null;
                    this.currentDrag = null;
                }
            }

            onTouchStart(e) {
                e.preventDefault();
                e.stopPropagation();
                const touch = e.touches[0];
                const mouseEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    preventDefault: () => {}
                };
                this.onMouseDown(mouseEvent);
            }

            onTouchMove(e) {
                e.preventDefault();
                e.stopPropagation();
                const touch = e.touches[0];
                const mouseEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    preventDefault: () => {}
                };
                this.onMouseMove(mouseEvent);
            }

            onTouchEnd(e) {
                e.preventDefault();
                e.stopPropagation();
                // Î“Î¹Î± touchend, Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ¼Îµ Ï„Î¿ Ï„ÎµÎ»ÎµÏ…Ï„Î±Î¯Î¿ changedTouches
                if (e.changedTouches && e.changedTouches.length > 0) {
                    const touch = e.changedTouches[0];
                    const mouseEvent = {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        preventDefault: () => {}
                    };
                    this.onMouseUp(mouseEvent);
                } else {
                    this.onMouseUp({});
                }
            }

            drawField() {
                // Î¦ÏŒÎ½Ï„Î¿ - Very dark grey to see crowd better
                ctx.fillStyle = '#1a1a1a'; // Dark grey instead of pure black
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ğŸ¦† Draw crowd AFTER background but BEFORE field
                if (this.crowdSystem) {
                    this.crowdSystem.draw();
                }
                
                // Î¤Î±Î¼Ï€Î­Î»Î± ÏƒÎºÎ¿Ï ÏƒÏ„Î¿ Ï†ÏŒÎ½Ï„Î¿ (Ï€Î¬Î½Ï‰ Î±Ï€ÏŒ Ï„Î¿ Î³Î®Ï€ÎµÎ´Î¿)
                this.drawScoreboard();

                // Î“Î®Ï€ÎµÎ´Î¿ - 20% Î¼Î¹ÎºÏÏŒÏ„ÎµÏÎ¿ Ï€Î»Î¬Ï„Î¿Ï‚
                const sideMargin = 240;  // Î‘Ï…Î¾Î·Î¼Î­Î½Î¿ Î±Ï€ÏŒ 80 (80 + 20% Ï„Î¿Ï… Ï€Î»Î¬Ï„Î¿Ï…Ï‚)
                const topMargin = 180;
                const bottomMargin = 80;
                
                // Î£Ï„ÏÎ¿Î³Î³Ï…Î»ÎµÎ¼Î­Î½Î¿ Î³Î®Ï€ÎµÎ´Î¿ Î¼Îµ Î±ÎºÏ„Î¯Î½Î± ÎºÎ±Î¼Ï€ÏÎ»Î·Ï‚ ÏƒÏ„Î¹Ï‚ Î³Ï‰Î½Î¯ÎµÏ‚
                const fieldCornerRadius = 30;
                const borderWidth = 45;  // Î Î»Î¬Ï„Î¿Ï‚ Ï„Î¿Ï… Î³ÎºÏÎ¹ Ï€ÎµÏÎ¹Î³ÏÎ¬Î¼Î¼Î±Ï„Î¿Ï‚ (Î±Ï…Î¾Î·Î¼Î­Î½Î¿ Î±Ï€ÏŒ 25)
                
                // Î“ÎºÏÎ¹ Ï€ÎµÏÎ¯Î³ÏÎ±Î¼Î¼Î± (ÎµÎ¾Ï‰Ï„ÎµÏÎ¹ÎºÏŒ Ï€Î»Î±Î¯ÏƒÎ¹Î¿)
                ctx.fillStyle = '#8a8a8a';  // Î“ÎºÏÎ¹ Ï‡ÏÏÎ¼Î± ÏŒÏ€Ï‰Ï‚ ÏƒÏ„Î·Î½ ÎµÎ¹ÎºÏŒÎ½Î±
                ctx.beginPath();
                ctx.roundRect(
                    sideMargin - borderWidth, 
                    topMargin - borderWidth, 
                    canvas.width - (sideMargin * 2) + (borderWidth * 2), 
                    canvas.height - topMargin - bottomMargin + (borderWidth * 2), 
                    fieldCornerRadius + 5
                );
                ctx.fill();
                
                // Î ÏÎ¬ÏƒÎ¹Î½Î¿ Î³Î®Ï€ÎµÎ´Î¿
                ctx.fillStyle = COLORS.green;
                ctx.beginPath();
                ctx.roundRect(sideMargin, topMargin, canvas.width - (sideMargin * 2), canvas.height - topMargin - bottomMargin, fieldCornerRadius);
                ctx.fill();
                
                // Î›ÎµÏ…ÎºÏŒ outline Ï„Î¿Ï… Î³Î·Ï€Î­Î´Î¿Ï…
                ctx.strokeStyle = COLORS.white;
                ctx.lineWidth = 6;  // Î‘Ï…Î¾Î·Î¼Î­Î½Î¿ Î±Ï€ÏŒ 3 ÏƒÎµ 6
                ctx.beginPath();
                ctx.roundRect(sideMargin, topMargin, canvas.width - (sideMargin * 2), canvas.height - topMargin - bottomMargin, fieldCornerRadius);
                ctx.stroke();

                // ÎœÎµÏƒÎ±Î¯Î± Î³ÏÎ±Î¼Î¼Î® - ÎšÎ¬Î¸ÎµÏ„Î·
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2, topMargin);
                ctx.lineTo(canvas.width / 2, canvas.height - bottomMargin);
                ctx.strokeStyle = COLORS.white;
                ctx.lineWidth = 6;  // Î‘Ï…Î¾Î·Î¼Î­Î½Î¿ Î±Ï€ÏŒ 3 ÏƒÎµ 6
                ctx.stroke();

                // ÎšÎµÎ½Ï„ÏÎ¹ÎºÏŒÏ‚ ÎºÏÎºÎ»Î¿Ï‚ - 50% Î¼ÎµÎ³Î±Î»ÏÏ„ÎµÏÎ¿Ï‚ (Î±Ï€ÏŒ 70 ÏƒÎµ 105)
                ctx.beginPath();
                const centerX = canvas.width / 2;
                const centerY = (topMargin + (canvas.height - bottomMargin)) / 2;
                ctx.arc(centerX, centerY, 105, 0, Math.PI * 2);  // Î‘Ï…Î¾Î·Î¼Î­Î½Î¿ Î±Ï€ÏŒ 70 ÏƒÎµ 105
                ctx.strokeStyle = COLORS.white;
                ctx.lineWidth = 6;  // Î‘Ï…Î¾Î·Î¼Î­Î½Î¿ Î±Ï€ÏŒ 3 ÏƒÎµ 6
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
                ctx.fillStyle = COLORS.black;
                ctx.fill();

                // Î ÎµÏÎ¹Î¿Ï‡Î­Ï‚ - ÎŸÏÎ¹Î¶ÏŒÎ½Ï„Î¹Î± (50% Î¼ÎµÎ³Î±Î»ÏÏ„ÎµÏÎµÏ‚)
                ctx.strokeStyle = COLORS.white;
                ctx.lineWidth = 6;  // Î‘Ï…Î¾Î·Î¼Î­Î½Î¿ Î±Ï€ÏŒ 3 ÏƒÎµ 6
                // Î‘ÏÎ¹ÏƒÏ„ÎµÏÎ¬
                ctx.strokeRect(sideMargin, centerY - 195, 150, 390);  // ÎœÎµÎ³Î¬Î»Î· Ï€ÎµÏÎ¹Î¿Ï‡Î® (100->150, 260->390)
                ctx.strokeRect(sideMargin, centerY - 120, 75, 240);   // ÎœÎ¹ÎºÏÎ® Ï€ÎµÏÎ¹Î¿Ï‡Î® (50->75, 160->240)
                
                // Î—Î¼Î¹ÎºÏÎºÎ»Î¹Î¿ Î±ÏÎ¹ÏƒÏ„ÎµÏÎ®Ï‚ Ï€ÎµÏÎ¹Î¿Ï‡Î®Ï‚ - Î•ÎÎ© Ï€ÏÎ¿Ï‚ Ï„Î± Î±ÏÎ¹ÏƒÏ„ÎµÏÎ¬
                ctx.beginPath();
                ctx.arc(sideMargin + 150, centerY, 60, -Math.PI / 2, Math.PI / 2);
                ctx.stroke();
                
                // Î”ÎµÎ¾Î¹Î¬
                ctx.strokeRect(canvas.width - sideMargin - 150, centerY - 195, 150, 390);  // ÎœÎµÎ³Î¬Î»Î· Ï€ÎµÏÎ¹Î¿Ï‡Î®
                ctx.strokeRect(canvas.width - sideMargin - 75, centerY - 120, 75, 240);   // ÎœÎ¹ÎºÏÎ® Ï€ÎµÏÎ¹Î¿Ï‡Î®
                
                // Î—Î¼Î¹ÎºÏÎºÎ»Î¹Î¿ Î´ÎµÎ¾Î¹Î¬Ï‚ Ï€ÎµÏÎ¹Î¿Ï‡Î®Ï‚ - Î•ÎÎ© Ï€ÏÎ¿Ï‚ Ï„Î± Î´ÎµÎ¾Î¹Î¬
                ctx.beginPath();
                ctx.arc(canvas.width - sideMargin - 150, centerY, 60, Math.PI / 2, Math.PI * 1.5);
                ctx.stroke();

                // Î¤ÎµÏ„Î±ÏÏ„Î·Î¼ÏŒÏÎ¹Î± ÎºÏŒÏÎ½ÎµÏ
                const cornerRadius = 40;
                ctx.lineWidth = 6;
                ctx.strokeStyle = COLORS.white;
                
                // Î Î¬Î½Ï‰ Î±ÏÎ¹ÏƒÏ„ÎµÏÎ¬
                ctx.beginPath();
                ctx.arc(sideMargin, topMargin, cornerRadius, 0, Math.PI / 2);
                ctx.stroke();
                
                // Î Î¬Î½Ï‰ Î´ÎµÎ¾Î¹Î¬
                ctx.beginPath();
                ctx.arc(canvas.width - sideMargin, topMargin, cornerRadius, Math.PI / 2, Math.PI);
                ctx.stroke();
                
                // ÎšÎ¬Ï„Ï‰ Î±ÏÎ¹ÏƒÏ„ÎµÏÎ¬
                ctx.beginPath();
                ctx.arc(sideMargin, canvas.height - bottomMargin, cornerRadius, Math.PI * 1.5, Math.PI * 2);
                ctx.stroke();
                
                // ÎšÎ¬Ï„Ï‰ Î´ÎµÎ¾Î¹Î¬
                ctx.beginPath();
                ctx.arc(canvas.width - sideMargin, canvas.height - bottomMargin, cornerRadius, Math.PI, Math.PI * 1.5);
                ctx.stroke();

                // Î¤Î­ÏÎ¼Î± Î±ÏÎ¹ÏƒÏ„ÎµÏÎ¬ (Player) - ÎšÏŒÎºÎºÎ¹Î½Î¿
                ctx.fillStyle = COLORS.lightRed;
                ctx.fillRect(sideMargin - 55, centerY - 90, 55, 180);
                ctx.strokeStyle = COLORS.white;
                ctx.lineWidth = 6;  // Î‘Ï…Î¾Î·Î¼Î­Î½Î¿ Î±Ï€ÏŒ 4 ÏƒÎµ 6
                ctx.strokeRect(sideMargin - 55, centerY - 90, 55, 180);

                // Î”Î¯Ï‡Ï„Ï… Î±ÏÎ¹ÏƒÏ„ÎµÏÎ¿Ï Ï„Î­ÏÎ¼Î±Ï„Î¿Ï‚ (Ï€ÏÏÏ„Î±)
                this.drawGoalNet(sideMargin - 55, centerY - 90, 55, 180, 'left');

                // Î¤Î­ÏÎ¼Î± Î´ÎµÎ¾Î¹Î¬ (Bot) - ÎœÏ€Î»Îµ
                ctx.fillStyle = COLORS.cyan;
                ctx.fillRect(canvas.width - sideMargin, centerY - 90, 55, 180);
                ctx.strokeStyle = COLORS.white;
                ctx.lineWidth = 6;  // Î‘Ï…Î¾Î·Î¼Î­Î½Î¿ Î±Ï€ÏŒ 4 ÏƒÎµ 6
                ctx.strokeRect(canvas.width - sideMargin, centerY - 90, 55, 180);
                
                // Î”Î¯Ï‡Ï„Ï… Î´ÎµÎ¾Î¹Î¿Ï Ï„Î­ÏÎ¼Î±Ï„Î¿Ï‚ (Ï€ÏÏÏ„Î±)
                this.drawGoalNet(canvas.width - sideMargin, centerY - 90, 55, 180, 'right');
                
                // Î¤Î‘ Î”ÎŸÎšÎ‘Î¡Î™Î‘ Î˜Î‘ Î£Î§Î•Î”Î™Î‘Î£Î¤ÎŸÎ¥Î Î£Î¤ÎŸ draw() - ÎŸÎ§Î™ Î•Î”Î©!
            }

            drawGoalPost(x, y, radius, color) {
                // Î£Ï‡ÎµÎ´Î¯Î±ÏƒÎ· Î´Î¿ÎºÎ±ÏÎ¹Î¿Ï (ÎºÏÎºÎ»Î¿Ï‚)
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                // Î Î¿Î»Ï Î»ÎµÏ€Ï„ÏŒ Î»ÎµÏ…ÎºÏŒ outline Î³Î¹Î± definition
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            drawGoalNet(x, y, width, height, side) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';  // Î›ÎµÏ…ÎºÏŒ Î·Î¼Î¹Î´Î¹Î±Ï†Î±Î½Î­Ï‚
                ctx.lineWidth = 1.5;
                
                const gridSize = 15;  // ÎœÎ­Î³ÎµÎ¸Î¿Ï‚ ÎºÎ¬Î¸Îµ Ï„ÎµÏ„ÏÎ¬Î³Ï‰Î½Î¿Ï… ÏƒÏ„Î¿ Î´Î¯Ï‡Ï„Ï…
                
                // ÎšÎ¬Î¸ÎµÏ„ÎµÏ‚ Î³ÏÎ±Î¼Î¼Î­Ï‚
                for (let i = gridSize; i < width; i += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x + i, y);
                    ctx.lineTo(x + i, y + height);
                    ctx.stroke();
                }
                
                // ÎŸÏÎ¹Î¶ÏŒÎ½Ï„Î¹ÎµÏ‚ Î³ÏÎ±Î¼Î¼Î­Ï‚
                for (let j = gridSize; j < height; j += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, y + j);
                    ctx.lineTo(x + width, y + j);
                    ctx.stroke();
                }
                
                // Î”Î¹Î±Î³ÏÎ½Î¹ÎµÏ‚ Î³Î¹Î± Ï€Î¹Î¿ ÏÎµÎ±Î»Î¹ÏƒÏ„Î¹ÎºÏŒ Î´Î¯Ï‡Ï„Ï… (Ï€ÏÎ¿Î±Î¹ÏÎµÏ„Î¹ÎºÏŒ)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';  // Î‘ÎºÏŒÎ¼Î± Ï€Î¹Î¿ Î·Î¼Î¹Î´Î¹Î±Ï†Î±Î½Î­Ï‚
                ctx.lineWidth = 1;
                
                for (let i = 0; i < width; i += gridSize) {
                    for (let j = 0; j < height; j += gridSize) {
                        ctx.beginPath();
                        ctx.moveTo(x + i, y + j);
                        ctx.lineTo(x + i + gridSize, y + j + gridSize);
                        ctx.stroke();
                    }
                }
            }

            drawScoreboard() {
                // ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ Î±Î½ ÎµÎ¯Î½Î±Î¹ mobile ÎºÎ±Î¹ landscape
                const isMobileLandscape = window.innerWidth < 1024 && window.innerWidth > window.innerHeight;
                
                if (isMobileLandscape) {
                    // ÎšÎ¬Î¸ÎµÏ„Î¿ scoreboard ÏƒÏ„Î¿ Î±ÏÎ¹ÏƒÏ„ÎµÏÏŒ Ï€Î»Î¬Î¹ Î³Î¹Î± mobile landscape
                    const scoreboardWidth = 80;
                    const scoreboardHeight = 200;
                    const scoreboardX = 10;
                    const scoreboardY = canvas.height / 2 - scoreboardHeight / 2;
                    
                    // ÎšÏÏÎ¹Î¿ background - Î†ÏƒÏ€ÏÎ¿
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                    ctx.roundRect(scoreboardX, scoreboardY, scoreboardWidth, scoreboardHeight, 15);
                    ctx.fill();
                    
                    // Outline
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.lineWidth = 2;
                    ctx.roundRect(scoreboardX, scoreboardY, scoreboardWidth, scoreboardHeight, 15);
                    ctx.stroke();
                    
                    // Î£ÎºÎ¿Ï Î¼Ï€Î»Îµ Î¿Î¼Î¬Î´Î±Ï‚ (Ï€Î¬Î½Ï‰)
                    ctx.font = 'bold 40px Arial';
                    ctx.fillStyle = '#2745e1';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.playerScore, scoreboardX + scoreboardWidth / 2, scoreboardY + 60);
                    
                    // Divider
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.font = 'bold 30px Arial';
                    ctx.fillText(':', scoreboardX + scoreboardWidth / 2, scoreboardY + scoreboardHeight / 2 + 10);
                    
                    // Î£ÎºÎ¿Ï ÎºÏŒÎºÎºÎ¹Î½Î·Ï‚ Î¿Î¼Î¬Î´Î±Ï‚ (ÎºÎ¬Ï„Ï‰)
                    ctx.font = 'bold 40px Arial';
                    ctx.fillStyle = '#ff3420';
                    ctx.fillText(this.botScore, scoreboardX + scoreboardWidth / 2, scoreboardY + scoreboardHeight - 40);
                    
                    // Reset
                    ctx.textAlign = 'left';
                } else {
                    // ÎŸÏÎ¹Î¶ÏŒÎ½Ï„Î¹Î¿ scoreboard Î³Î¹Î± desktop ÎºÎ±Î¹ portrait
                    const scoreboardWidth = 400;
                    const scoreboardHeight = 100;
                    const scoreboardX = canvas.width / 2 - scoreboardWidth / 2;
                    const scoreboardY = 20;
                    
                    // ÎšÏÏÎ¹Î¿ background - Î†ÏƒÏ€ÏÎ¿
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                    ctx.roundRect(scoreboardX, scoreboardY, scoreboardWidth, scoreboardHeight, 15);
                    ctx.fill();
                    
                    // ÎœÎ±ÏÏÎ¿ outline
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.lineWidth = 2;
                    ctx.roundRect(scoreboardX, scoreboardY, scoreboardWidth, scoreboardHeight, 15);
                    ctx.stroke();
                    
                    // Î‘ÏÎ¹ÏƒÏ„ÎµÏÏŒ Ï„Î¼Î®Î¼Î± - ÎœÏ€Î»Îµ Î¿Î¼Î¬Î´Î± (Player)
                    const leftSectionX = scoreboardX + 20;
                    const leftSectionY = scoreboardY + 25;
                    
                    // Î£ÎºÎ¿Ï Î¼Ï€Î»Îµ Î¿Î¼Î¬Î´Î±Ï‚ (Player - Î±ÏÎ¹ÏƒÏ„ÎµÏÎ¬)
                    ctx.font = 'bold 48px Arial';
                    ctx.fillStyle = '#2745e1';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.playerScore, leftSectionX + 50, leftSectionY + 40);
                    
                    // Divider ÏƒÏ„Î· Î¼Î­ÏƒÎ·
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.font = 'bold 40px Arial';
                    ctx.fillText(':', canvas.width / 2, leftSectionY + 38);
                    
                    // Î”ÎµÎ¾Î¯ Ï„Î¼Î®Î¼Î± - ÎšÏŒÎºÎºÎ¹Î½Î· Î¿Î¼Î¬Î´Î± (Bot)
                    const rightSectionX = scoreboardX + scoreboardWidth - 120;
                    
                    // Î£ÎºÎ¿Ï ÎºÏŒÎºÎºÎ¹Î½Î·Ï‚ Î¿Î¼Î¬Î´Î±Ï‚ (Bot - Î´ÎµÎ¾Î¹Î¬)
                    ctx.font = 'bold 48px Arial';
                    ctx.fillStyle = '#ff3420';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.botScore, rightSectionX + 50, leftSectionY + 40);
                    
                    // Reset text align
                    ctx.textAlign = 'left';
                }
            }

            freezeAllMovement() {
                // ğŸš¨ Î£Î¤Î‘ÎœÎ‘Î¤Î‘ ÎŸÎ›ÎŸÎ¥Î£ Ï„Î¿Ï…Ï‚ Ï€Î±Î¯ÎºÏ„ÎµÏ‚ ÎºÎ±Î¹ Ï„Î· Î¼Ï€Î¬Î»Î± Î‘ÎœÎ•Î£Î©Î£
                this.playerTeam.forEach(player => {
                    player.vx = 0;
                    player.vy = 0;
                    player.moving = false;
                });
                
                this.botTeam.forEach(player => {
                    player.vx = 0;
                    player.vy = 0;
                    player.moving = false;
                });
                
                // Î£Ï„Î±Î¼Î¬Ï„Î± Ï„Î· Î¼Ï€Î¬Î»Î±
                this.ball.vx = 0;
                this.ball.vy = 0;
                
                console.log('ğŸš« All movement frozen after goal');
            }

            resetPositions() {
                // Reset Ï€Î±Î¹ÎºÏ„ÏÎ½ ÏƒÏ„Î¹Ï‚ Î±ÏÏ‡Î¹ÎºÎ­Ï‚ Î¸Î­ÏƒÎµÎ¹Ï‚
                this.playerTeam.forEach((player, i) => {
                    player.x = this.initialPositions.player[i].x;
                    player.y = this.initialPositions.player[i].y;
                    player.vx = 0;
                    player.vy = 0;
                    player.moving = false;
                });
                
                this.botTeam.forEach((player, i) => {
                    player.x = this.initialPositions.bot[i].x;
                    player.y = this.initialPositions.bot[i].y;
                    player.vx = 0;
                    player.vy = 0;
                    player.moving = false;
                });
                
                // Reset Î¼Ï€Î¬Î»Î±Ï‚
                this.ball.reset();
                
                // ğŸ² Reset bot shot counter for new variety
                this.botShotCount = 0;
            }

            botMove() {
                // Î£Ï„Î¿ multiplayer Î® local 1v1 mode, Ï„Î¿ bot AI Î±Ï€ÎµÎ½ÎµÏÎ³Î¿Ï€Î¿Î¹ÎµÎ¯Ï„Î±Î¹
                if (this.isMultiplayer || this.isLocal1v1) return;
                
                // âœ… Phase 1.1: Bot Ï€Î±Î¯Î¶ÎµÎ¹ Î¼ÏŒÎ½Î¿ ÏŒÏ„Î±Î½ ÎµÎ¯Î½Î±Î¹ Î· ÏƒÎµÎ¹ÏÎ¬ Ï„Î¿Ï…
                if (this.currentTurn !== 'bot') return;
                if (!this.turnComplete) return;

                // ÎœÎ¹ÎºÏÎ® ÎºÎ±Î¸Ï…ÏƒÏ„Î­ÏÎ·ÏƒÎ· Î³Î¹Î± Ï€Î¹Î¿ Ï†Ï…ÏƒÎ¹ÎºÎ® Î±Î¯ÏƒÎ¸Î·ÏƒÎ·
                if (!this.botThinkingTime) {
                    this.botThinkingTime = Date.now();
                }
                
                if (Date.now() - this.botThinkingTime < 1000) return; // 1 Î´ÎµÏ…Ï„ÎµÏÏŒÎ»ÎµÏ€Ï„Î¿ ÏƒÎºÎ­ÏˆÎ·
                
                this.botThinkingTime = null;
                
                // ğŸ² Initialize shot counter
                if (!this.botShotCount) this.botShotCount = 0;

                // âœ… Phase 1.2: Î ÏÎ¿ÏƒÎ´Î¹Î¿ÏÎ¹ÏƒÎ¼ÏŒÏ‚ Î¸Î­ÏƒÎ·Ï‚ player goal (Î±ÏÎ¹ÏƒÏ„ÎµÏÎ¬)
                const sideMargin = 240;
                const topMargin = 180;
                const bottomMargin = 80;
                const fieldCenterY = (topMargin + (canvas.height - bottomMargin)) / 2;
                const playerGoalX = sideMargin - 27.5; // ÎšÎ­Î½Ï„ÏÎ¿ Ï„Î­ÏÎ¼Î±Ï„Î¿Ï‚
                const playerGoalY = fieldCenterY;

                // âœ… Phase 3: Smart Player Selection - Î’ÏÎµÏ‚ Ï„Î¿Î½ ÎºÎ±Î»ÏÏ„ÎµÏÎ¿ Ï€Î±Î¯ÎºÏ„Î·
                let bestPlayer = null;
                let bestScore = -Infinity;
                
                // ğŸ² FIX 1: Random opening moves (Ï€ÏÏÏ„Î± 3 shots)
                if (this.botShotCount < 3 && Math.random() < 0.6) {
                    // 60% Ï€Î¹Î¸Î±Î½ÏŒÏ„Î·Ï„Î± Ï„Ï…Ï‡Î±Î¯Î¿Ï… Ï€Î±Î¯ÎºÏ„Î· ÏƒÏ„Î± Ï€ÏÏÏ„Î± 3 shots
                    const availablePlayers = this.botTeam.filter(bot => {
                        const dist = Math.sqrt((bot.x - this.ball.x)**2 + (bot.y - this.ball.y)**2);
                        return dist > 50 && dist < 600; // ÎŒÏ‡Î¹ Ï€Î¿Î»Ï ÎºÎ¿Î½Ï„Î¬/Î¼Î±ÎºÏÎ¹Î¬
                    });
                    
                    if (availablePlayers.length > 0) {
                        bestPlayer = availablePlayers[Math.floor(Math.random() * availablePlayers.length)];
                        console.log('ğŸ² Bot chose RANDOM player for variety!');
                    }
                }

                // Î‘Î½ Î´ÎµÎ½ ÎµÏ€Î¹Î»Î­Ï‡Î¸Î·ÎºÎµ Ï„Ï…Ï‡Î±Î¯Î¿Ï‚, Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¯Î·ÏƒÎµ smart selection
                if (!bestPlayer) {
                    for (let bot of this.botTeam) {
                        const score = this.evaluatePlayerQuality(bot, this.ball, {x: playerGoalX, y: playerGoalY});
                        if (score > bestScore) {
                            bestScore = score;
                            bestPlayer = bot;
                        }
                    }
                }

                if (!bestPlayer) return;
                
                // Increment shot counter
                this.botShotCount++;

                // âœ… Phase 4: Adaptive Strategy - ÎšÎ±Î¸ÏŒÏÎ¹ÏƒÎµ ÏƒÏ„ÏÎ±Ï„Î·Î³Î¹ÎºÎ®
                const strategy = this.determineStrategy();
                
                // âœ… Phase 2: Goal-Oriented Aiming - Î¥Ï€Î¿Î»Î¿Î³Î¹ÏƒÎ¼ÏŒÏ‚ shot Ï€ÏÎ¿Ï‚ Ï„Î­ÏÎ¼Î±
                const shotVector = this.calculateShotToGoal(
                    bestPlayer, 
                    this.ball, 
                    {x: playerGoalX, y: playerGoalY},
                    strategy
                );

                // Fallback: Î‘Î½ Î´ÎµÎ½ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± ÏƒÎºÎ¿ÏÎ¬ÏÎµÎ¹, Ï‡Ï„ÏÏ€Î± Î±Ï€Î»Î¬ Ï„Î·Î½ Î¼Ï€Î¬Î»Î±
                if (!shotVector || !shotVector.canShoot) {
                    const dx = this.ball.x - bestPlayer.x;
                    const dy = this.ball.y - bestPlayer.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 10) { // Î‘Î½ Î· Î¼Ï€Î¬Î»Î± ÎµÎ¯Î½Î±Î¹ Ï€Î¿Î»Ï ÎºÎ¿Î½Ï„Î¬, skip
                        const power = 30;
                        bestPlayer.vx = (dx / dist) * power;
                        bestPlayer.vy = (dy / dist) * power;
                        bestPlayer.moving = true;
                        this.turnComplete = false;
                    }
                    return;
                }

                // âœ… Phase 5: Human-like Imperfection - Î ÏÏŒÏƒÎ¸ÎµÏƒÎµ Î»Î¬Î¸Î¿Ï‚
                const finalShot = this.addHumanError(shotVector.vx, shotVector.vy, 0.12);
                
                bestPlayer.vx = finalShot.vx;
                bestPlayer.vy = finalShot.vy;
                bestPlayer.moving = true;
                
                // ÎÎµÎºÎ¹Î½Î¬ÎµÎ¹ Î· ÏƒÎµÎ¹ÏÎ¬
                this.turnComplete = false;
            }

            // âœ… Phase 2.2: Î¥Ï€Î¿Î»Î¿Î³Î¹ÏƒÎ¼ÏŒÏ‚ shot Ï€Î¿Ï… ÏƒÏ„Î¿Ï‡ÎµÏÎµÎ¹ Ï„Î¿ Ï„Î­ÏÎ¼Î±
            calculateShotToGoal(player, ball, goal, strategy) {
                // 2.2a: Î”Î¹Î¬Î½Ï…ÏƒÎ¼Î± player â†’ ball
                const toBallX = ball.x - player.x;
                const toBallY = ball.y - player.y;
                const distToBall = Math.sqrt(toBallX * toBallX + toBallY * toBallY);
                
                // ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ Î±Î½ ÎµÎ¯Î½Î±Î¹ Ï€Î¿Î»Ï ÎºÎ¿Î½Ï„Î¬ Î® Ï€Î¿Î»Ï Î¼Î±ÎºÏÎ¹Î¬ - Ï€Î¹Î¿ Î±Î½ÎµÎºÏ„Î¹ÎºÎ¬ ÏŒÏÎ¹Î±
                if (distToBall < 10) {
                    return {canShoot: false}; // Î Î¿Î»Ï ÎºÎ¿Î½Ï„Î¬
                }
                
                if (distToBall > 800) {
                    return {canShoot: false}; // Î Î¿Î»Ï Î¼Î±ÎºÏÎ¹Î¬
                }

                // 2.2b: ÎšÎ±Î½Î¿Î½Î¹ÎºÎ¿Ï€Î¿Î¯Î·ÏƒÎ· ÎºÎ±Ï„ÎµÏÎ¸Ï…Î½ÏƒÎ·Ï‚ Ï€ÏÎ¿Ï‚ Î¼Ï€Î¬Î»Î±
                const dirX = toBallX / distToBall;
                const dirY = toBallY / distToBall;
                
                // ğŸš¨ FIX 2: Own Goal Prevention
                // Î¥Ï€Î¿Î»Î¿Î³Î¹ÏƒÎ¼ÏŒÏ‚ Ï€Î¿Ï… Î¸Î± Ï€Î¬ÎµÎ¹ Î· Î¼Ï€Î¬Î»Î± ÎœÎ•Î¤Î‘ Ï„Î¿ Ï‡Ï„ÏÏ€Î·Î¼Î±
                const predictedBallX = ball.x + (dirX * 300); // Î ÏÎ¿Î²Î¿Î»Î® 300px
                
                // Î¤Î¿ BOT Ï„Î­ÏÎ¼Î± ÎµÎ¯Î½Î±Î¹ Î”Î•ÎÎ™Î‘ (canvas.width - 240)
                const botGoalX = canvas.width - 240;
                const playerGoalX = 240;
                
                // ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚: Î— Î¼Ï€Î¬Î»Î± Ï€Î¬ÎµÎ¹ Ï€ÏÎ¿Ï‚ Ï„Î¿ Î”Î™ÎšÎŸ ÎœÎ‘Î£ Ï„Î­ÏÎ¼Î± (Î´ÎµÎ¾Î¹Î¬);
                const currentBallToOwnGoal = ball.x - botGoalX; // Î‘ÏÎ½Î·Ï„Î¹ÎºÏŒ = Î¼Ï€Î¬Î»Î± Î±ÏÎ¹ÏƒÏ„ÎµÏÎ¬ Î±Ï€ÏŒ bot goal
                const predictedBallToOwnGoal = predictedBallX - botGoalX;
                
                // Î‘Î½ Î· Î¼Ï€Î¬Î»Î± Ï€Î»Î·ÏƒÎ¹Î¬Î¶ÎµÎ¹ Ï„Î¿ Î´Î¹ÎºÏŒ Î¼Î±Ï‚ Ï„Î­ÏÎ¼Î± (Ï€Î¬ÎµÎ¹ Î´ÎµÎ¾Î¹Î¬)
                const goingTowardsOwnGoal = predictedBallToOwnGoal > currentBallToOwnGoal;
                
                if (goingTowardsOwnGoal && Math.abs(predictedBallToOwnGoal) < 400) {
                    // ÎšÎ™ÎÎ”Î¥ÎÎŸÎ£ Î‘Î¥Î¤ÎŸÎ“ÎšÎŸÎ› - Don't shoot!
                    console.warn('âš ï¸ Bot avoided potential OWN GOAL! Predicted X:', predictedBallX.toFixed(0));
                    return {canShoot: false};
                }
                
                // 2.2c: Î”Î¹Î¬Î½Ï…ÏƒÎ¼Î± ball â†’ goal
                const ballToGoalX = goal.x - ball.x;
                const ballToGoalY = goal.y - ball.y;
                
                // Power Î²Î¬ÏƒÎµÎ¹ strategy ÎºÎ±Î¹ Î±Ï€ÏŒÏƒÏ„Î±ÏƒÎ·Ï‚
                let basePower;
                if (strategy === 'aggressive') {
                    basePower = 20 + Math.random() * 8; // 20-28
                } else if (strategy === 'defensive') {
                    basePower = 12 + Math.random() * 8; // 12-20
                } else {
                    basePower = 15 + Math.random() * 8; // 15-23
                }
                
                // Î ÏÎ¿ÏƒÎ±ÏÎ¼Î¿Î³Î® power Î²Î¬ÏƒÎµÎ¹ Î±Ï€ÏŒÏƒÏ„Î±ÏƒÎ·Ï‚
                if (distToBall > 400) {
                    basePower *= 1.15; // Î•Î»Î±Ï†ÏÎ¬ Î±ÏÎ¾Î·ÏƒÎ· Î³Î¹Î± Î¼Î±ÎºÏÎ¹Î½Î¬ shots (Î±Ï€ÏŒ 1.2)
                }
                
                // 2.2d: Î•Ï€Î¹ÏƒÏ„ÏÎ¿Ï†Î® ÎºÎ±Ï„ÎµÏÎ¸Ï…Î½ÏƒÎ·Ï‚
                return {
                    canShoot: true,
                    vx: dirX * basePower,
                    vy: dirY * basePower,
                    quality: 1 - (distToBall / 800) // Quality score 0-1
                };
            }

            // âœ… Phase 3.1: Î‘Î¾Î¹Î¿Î»ÏŒÎ³Î·ÏƒÎ· Ï€Î¿Î¹ÏŒÏ„Î·Ï„Î±Ï‚ Ï€Î±Î¯ÎºÏ„Î·
            evaluatePlayerQuality(player, ball, goal) {
                // 3.1a: Distance score (Ï€Î¹Î¿ ÎºÎ¿Î½Ï„Î¬ = ÎºÎ±Î»ÏÏ„ÎµÏÎ¿)
                const distToBall = Math.sqrt(
                    (ball.x - player.x) ** 2 + (ball.y - player.y) ** 2
                );
                
                // Î Î¹Î¿ Î±Î½ÎµÎºÏ„Î¹ÎºÏŒ distance scoring
                const distanceScore = Math.max(0, 1 - distToBall / 800);

                // 3.1b: Angle score (ÎºÎ±Î»ÏÏ„ÎµÏÎ· Î³Ï‰Î½Î¯Î± Î³Î¹Î± ÏƒÎºÎ¿ÏÎ¬ÏÎ¹ÏƒÎ¼Î±)
                const playerToBallX = ball.x - player.x;
                const playerToBallY = ball.y - player.y;
                const ballToGoalX = goal.x - ball.x;
                const ballToGoalY = goal.y - ball.y;
                
                // Î¥Ï€Î¿Î»Î¿Î³Î¹ÏƒÎ¼ÏŒÏ‚ Î³Ï‰Î½Î¯Î±Ï‚ player-ball-goal
                const angle1 = Math.atan2(playerToBallY, playerToBallX);
                const angle2 = Math.atan2(ballToGoalY, ballToGoalX);
                let angleDiff = Math.abs(angle1 - angle2);
                if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                
                // Î†ÏÎ¹ÏƒÏ„Î· Î³Ï‰Î½Î¯Î± = 180Â° (ÎµÏ…Î¸ÎµÎ¯Î± Î³ÏÎ±Î¼Î¼Î® player-ball-goal)
                const angleScore = Math.max(0.2, 1 - (angleDiff / Math.PI)); // Î¤Î¿Ï…Î»Î¬Ï‡Î¹ÏƒÏ„Î¿Î½ 0.2

                // 3.1d: Weighted sum - Ï„Î¿Ï…Î»Î¬Ï‡Î¹ÏƒÏ„Î¿Î½ 0.1 Î³Î¹Î± Î½Î± Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Ï€Î¬Î½Ï„Î± ÎºÎ¬Ï€Î¿Î¹Î¿Ï‚ score
                const totalScore = Math.max(0.1, (distanceScore * 0.4) + (angleScore * 0.6));
                
                return totalScore;
            }

            // âœ… Phase 4.2: ÎšÎ±Î¸Î¿ÏÎ¹ÏƒÎ¼ÏŒÏ‚ ÏƒÏ„ÏÎ±Ï„Î·Î³Î¹ÎºÎ®Ï‚
            determineStrategy() {
                if (this.botScore < this.playerScore) {
                    return 'aggressive'; // Î§Î¬Î½ÎµÎ¹, Ï€Î¹Î¿ ÎµÏ€Î¹Î¸ÎµÏ„Î¹ÎºÏŒ
                } else if (this.botScore > this.playerScore) {
                    return 'defensive'; // ÎšÎµÏÎ´Î¯Î¶ÎµÎ¹, Ï€Î¹Î¿ Ï€ÏÎ¿ÏƒÎµÎºÏ„Î¹ÎºÏŒ
                } else {
                    return 'balanced'; // Î™ÏƒÎ¿Ï€Î±Î»Î¯Î±
                }
            }

            // âœ… Phase 5.2: Î ÏÏŒÏƒÎ¸ÎµÏƒÎµ Î±Î½Î¸ÏÏÏ€Î¹Î½Î¿ Î»Î¬Î¸Î¿Ï‚
            addHumanError(vx, vy, errorRate) {
                // 15% Ï€Î¹Î¸Î±Î½ÏŒÏ„Î·Ï„Î± Î»Î¬Î¸Î¿Ï…Ï‚
                if (Math.random() > errorRate) {
                    return {vx, vy}; // Î¤Î­Î»ÎµÎ¹Î¿ shot
                }

                // Î ÏÏŒÏƒÎ¸ÎµÏƒÎµ Ï„Ï…Ï‡Î±Î¯Î± Î±Ï€ÏŒÎºÎ»Î¹ÏƒÎ·
                const speed = Math.sqrt(vx * vx + vy * vy);
                const angle = Math.atan2(vy, vx);
                
                // Â±10 degrees Ï„Ï…Ï‡Î±Î¯Î± Î±Ï€ÏŒÎºÎ»Î¹ÏƒÎ·
                const angleError = (Math.random() - 0.5) * (Math.PI / 18); // Â±10Â°
                const newAngle = angle + angleError;
                
                // Â±15% Î±Ï€ÏŒÎºÎ»Î¹ÏƒÎ· ÏƒÏ„Î· Î´ÏÎ½Î±Î¼Î·
                const powerError = 0.85 + Math.random() * 0.3; // 0.85-1.15
                const newSpeed = speed * powerError;
                
                return {
                    vx: Math.cos(newAngle) * newSpeed,
                    vy: Math.sin(newAngle) * newSpeed
                };
            }

            checkTurnComplete() {
                // ğŸš¨ Î‘Î½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Î¼Î®Î½Ï…Î¼Î± Î³ÎºÎ¿Î», Î”Î•Î ÎµÎ»Î­Î³Ï‡Î¿Ï…Î¼Îµ Ï„Î¯Ï€Î¿Ï„Î±
                if (this.goalMessage) return;
                
                // Î•Î»Î­Î³Ï‡ÎµÎ¹ Î±Î½ ÏŒÎ»Î± Î­Ï‡Î¿Ï…Î½ ÏƒÏ„Î±Î¼Î±Ï„Î®ÏƒÎµÎ¹
                const anyMoving = [...this.playerTeam, ...this.botTeam].some(p => p.moving);
                const ballMoving = Math.abs(this.ball.vx) > 0.3 || Math.abs(this.ball.vy) > 0.3;
                
                if (!anyMoving && !ballMoving && !this.turnComplete) {
                    // ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ Î±Î½ ÎºÎ¬Ï€Î¿Î¹Î¿Ï‚ Ï€Î±Î¯ÎºÏ„Î·Ï‚ ÎµÎ¯Î½Î±Î¹ Î¼Î­ÏƒÎ± ÏƒÏ„Î¿ Ï„Î­ÏÎ¼Î± > 70%
                    this.checkPlayersInGoal();
                    
                    this.turnComplete = true;
                    // Î‘Î»Î»Î±Î³Î® ÏƒÎµÎ¹ÏÎ¬Ï‚
                    this.currentTurn = this.currentTurn === 'player' ? 'bot' : 'player';
                    
                    // ÎœÎµÏ„Î¬ Ï„Î¿ Ï€ÏÏÏ„Î¿ shot, Ï„Î¿ flag Î³Î¯Î½ÎµÏ„Î±Î¹ false
                    if (this.ball.firstShotAfterReset) {
                        this.ball.firstShotAfterReset = false;
                    }
                }
            }

            checkPlayersInGoal() {
                const sideMargin = 240;
                const topMargin = 180;
                const bottomMargin = 80;
                const centerY = (topMargin + (canvas.height - bottomMargin)) / 2;
                const goalHeight = 180;
                const goalTop = centerY - (goalHeight / 2);
                const goalBottom = centerY + (goalHeight / 2);
                const goalWidth = 55;
                
                const allPlayers = [...this.playerTeam, ...this.botTeam];
                
                allPlayers.forEach(player => {
                    let insideGoalPercentage = 0;
                    let targetX, targetY;
                    let inLeftGoal = false;
                    let inRightGoal = false;
                    
                    // ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ Î±ÏÎ¹ÏƒÏ„ÎµÏÏŒ Ï„Î­ÏÎ¼Î±
                    if (player.x < sideMargin && player.y > goalTop && player.y < goalBottom) {
                        const distanceInside = sideMargin - player.x;
                        insideGoalPercentage = (distanceInside / player.radius) * 100;
                        inLeftGoal = true;
                    }
                    
                    // ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ Î´ÎµÎ¾Î¯ Ï„Î­ÏÎ¼Î±
                    if (player.x > canvas.width - sideMargin && player.y > goalTop && player.y < goalBottom) {
                        const distanceInside = player.x - (canvas.width - sideMargin);
                        insideGoalPercentage = (distanceInside / player.radius) * 100;
                        inRightGoal = true;
                    }
                    
                    // Î‘Î½ ÎµÎ¯Î½Î±Î¹ > 70% Î¼Î­ÏƒÎ±, Î²Î³Î¬Î»Îµ Ï„Î¿Î½ Î­Î¾Ï‰ Î¼Îµ animation
                    if (insideGoalPercentage > 70) {
                        // Î¤Ï…Ï‡Î±Î¯Î± Î¸Î­ÏƒÎ· ÏƒÏ„Î·Î½ ÎºÎ¿ÏÏ…Ï†Î® Ï„Î·Ï‚ Î¼ÎµÎ³Î¬Î»Î·Ï‚ Ï€ÎµÏÎ¹Î¿Ï‡Î®Ï‚
                        const penaltyBoxWidth = 150;
                        const penaltyBoxHeight = 390;
                        
                        if (inLeftGoal) {
                            // Î‘ÏÎ¹ÏƒÏ„ÎµÏÎ® Î¼ÎµÎ³Î¬Î»Î· Ï€ÎµÏÎ¹Î¿Ï‡Î® - ÎºÎ¿ÏÏ…Ï†Î® (Î´ÎµÎ¾Î¹Î¬ Î³ÏÎ±Î¼Î¼Î®)
                            targetX = sideMargin + penaltyBoxWidth;
                            targetY = centerY - penaltyBoxHeight/2 + Math.random() * penaltyBoxHeight;
                        } else if (inRightGoal) {
                            // Î”ÎµÎ¾Î¹Î¬ Î¼ÎµÎ³Î¬Î»Î· Ï€ÎµÏÎ¹Î¿Ï‡Î® - ÎºÎ¿ÏÏ…Ï†Î® (Î±ÏÎ¹ÏƒÏ„ÎµÏÎ® Î³ÏÎ±Î¼Î¼Î®)
                            targetX = canvas.width - sideMargin - penaltyBoxWidth;
                            targetY = centerY - penaltyBoxHeight/2 + Math.random() * penaltyBoxHeight;
                        }
                        
                        // Î•Î½ÎµÏÎ³Î¿Ï€Î¿Î¯Î·ÏƒÎ· animation
                        player.isRelocating = true;
                        player.relocateTarget = { x: targetX, y: targetY };
                        player.relocateStartTime = Date.now();
                        player.relocateStartPos = { x: player.x, y: player.y };
                    }
                });
            }

            update() {
                // ğŸ¦† Update crowd animation
                this.crowdSystem.update(16); // Approximate 60fps delta
                
                // ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ Î±Î½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Î¼Î®Î½Ï…Î¼Î± Î³ÎºÎ¿Î»
                if (this.goalMessage) {
                    const elapsed = Date.now() - this.goalMessageTime;
                    if (elapsed >= 2000) {  // 2 Î´ÎµÏ…Ï„ÎµÏÏŒÎ»ÎµÏ€Ï„Î±
                        this.goalMessage = null;
                        this.resetPositions();
                        this.turnComplete = true;
                    }
                    return;  // Î”ÎµÎ½ ÎµÎ½Î·Î¼ÎµÏÏÎ½Î¿Ï…Î¼Îµ Ï„Î¯Ï€Î¿Ï„Î± Î¬Î»Î»Î¿ ÏŒÏƒÎ¿ ÎµÎ¼Ï†Î±Î½Î¯Î¶ÎµÏ„Î±Î¹ Ï„Î¿ Î¼Î®Î½Ï…Î¼Î±
                }
                
                const goal = this.ball.update();
                
                if (goal === 'player_goal') {
                    this.botScore++;
                    this.goalMessage = 'Î“ÎšÎŸÎ›!\nÎ£ÎºÏŒÏÎ±ÏÎµ Ï„Î¿ BOT!';
                    this.goalMessageTime = Date.now();
                    this.currentTurn = 'player'; // Î‘Ï…Ï„ÏŒÏ‚ Ï€Î¿Ï… Î­Ï†Î±Î³Îµ Î³ÎºÎ¿Î» Ï€Î±Î¯Î¶ÎµÎ¹
                    this.freezeAllMovement(); // ğŸš¨ Î£Î¤Î‘ÎœÎ‘Î¤Î‘ ÎŸÎ›Î‘ Î‘ÎœÎ•Î£Î©Î£
                } else if (goal === 'bot_goal') {
                    this.playerScore++;
                    this.goalMessage = 'Î“ÎšÎŸÎ›!\nÎ£ÎºÏŒÏÎ±ÏÎµÏ‚!';
                    this.goalMessageTime = Date.now();
                    this.currentTurn = 'bot'; // Î‘Ï…Ï„ÏŒÏ‚ Ï€Î¿Ï… Î­Ï†Î±Î³Îµ Î³ÎºÎ¿Î» Ï€Î±Î¯Î¶ÎµÎ¹
                    this.freezeAllMovement(); // ğŸš¨ Î£Î¤Î‘ÎœÎ‘Î¤Î‘ ÎŸÎ›Î‘ Î‘ÎœÎ•Î£Î©Î£
                } else if (goal === 'foul_player_goal') {
                    // Î¦Î‘ÎŸÎ¥Î›! Î¤Î¿ bot Ï€ÏÎ¿ÏƒÏ€Î¬Î¸Î·ÏƒÎµ Î½Î± ÏƒÎºÎ¿ÏÎ¬ÏÎµÎ¹ Î±Ï€ÏŒ Ï„Î¿ ÎºÎ­Î½Ï„ÏÎ¿
                    this.goalMessage = 'Î¦Î‘ÎŸÎ¥Î›!\nÎ”ÎµÎ½ Î¼Ï€Î¿ÏÎµÎ¯Ï‚ Î½Î± ÏƒÎºÎ¿ÏÎ¬ÏÎµÎ¹Ï‚\nÎ±Ï€ÏŒ Ï„Î¿ ÎºÎ­Î½Ï„ÏÎ¿!';
                    this.goalMessageTime = Date.now();
                    this.currentTurn = 'player'; // Î Î±Î¯Î¶ÎµÎ¹ Î¿ player
                    this.freezeAllMovement(); // ğŸš¨ Î£Î¤Î‘ÎœÎ‘Î¤Î‘ ÎŸÎ›Î‘ Î‘ÎœÎ•Î£Î©Î£
                } else if (goal === 'foul_bot_goal') {
                    // Î¦Î‘ÎŸÎ¥Î›! ÎŸ player Ï€ÏÎ¿ÏƒÏ€Î¬Î¸Î·ÏƒÎµ Î½Î± ÏƒÎºÎ¿ÏÎ¬ÏÎµÎ¹ Î±Ï€ÏŒ Ï„Î¿ ÎºÎ­Î½Ï„ÏÎ¿
                    this.goalMessage = 'Î¦Î‘ÎŸÎ¥Î›!\nÎ”ÎµÎ½ Î¼Ï€Î¿ÏÎµÎ¯Ï‚ Î½Î± ÏƒÎºÎ¿ÏÎ¬ÏÎµÎ¹Ï‚\nÎ±Ï€ÏŒ Ï„Î¿ ÎºÎ­Î½Ï„ÏÎ¿!';
                    this.goalMessageTime = Date.now();
                    this.currentTurn = 'bot'; // Î Î±Î¯Î¶ÎµÎ¹ Î¿ bot
                    this.freezeAllMovement(); // ğŸš¨ Î£Î¤Î‘ÎœÎ‘Î¤Î‘ ÎŸÎ›Î‘ Î‘ÎœÎ•Î£Î©Î£
                }

                // ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ Î±Î½ Ï„ÎµÎ»ÎµÎ¯Ï‰ÏƒÎµ Î· ÏƒÎµÎ¹ÏÎ¬
                this.checkTurnComplete();
                
                // Bot ÎºÎ¯Î½Î·ÏƒÎ·
                this.botMove();

                // Î•Î½Î·Î¼Î­ÏÏ‰ÏƒÎ· Ï€Î±Î¹ÎºÏ„ÏÎ½
                const allPlayers = [...this.playerTeam, ...this.botTeam];
                allPlayers.forEach(player => {
                    player.update();
                    player.checkCollision(this.ball);
                    
                    // Collision Î¼Îµ Î´Î¿ÎºÎ¬ÏÎ¹Î±
                    this.goalPosts.forEach(post => {
                        this.checkGoalPostCollision(player, post);
                    });
                });
                
                // Collision Î¼Ï€Î¬Î»Î±Ï‚ Î¼Îµ Î´Î¿ÎºÎ¬ÏÎ¹Î±
                this.goalPosts.forEach(post => {
                    this.checkBallGoalPostCollision(this.ball, post);
                });
                
                // ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ ÏƒÏ…Î³ÎºÏÎ¿ÏÏƒÎµÏ‰Î½ Î¼ÎµÏ„Î±Î¾Ï Ï€Î±Î¹ÎºÏ„ÏÎ½
                for (let i = 0; i < allPlayers.length; i++) {
                    for (let j = i + 1; j < allPlayers.length; j++) {
                        allPlayers[i].checkPlayerCollision(allPlayers[j]);
                    }
                }
            }

            checkGoalPostCollision(player, post) {
                const dx = player.x - post.x;
                const dy = player.y - post.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const minDistance = player.radius + post.radius;
                
                if (distance < minDistance && distance > 0) {
                    // Î§Ï‰ÏÎ¹ÏƒÎ¼ÏŒÏ‚
                    const angle = Math.atan2(dy, dx);
                    const overlap = minDistance - distance;
                    
                    player.x += Math.cos(angle) * (overlap + 2);
                    player.y += Math.sin(angle) * (overlap + 2);
                    
                    // Bounce
                    const relVelocity = player.vx * Math.cos(angle) + player.vy * Math.sin(angle);
                    if (relVelocity < 0) {
                        player.vx -= 1.5 * relVelocity * Math.cos(angle);
                        player.vy -= 1.5 * relVelocity * Math.sin(angle);
                    }
                }
            }

            checkBallGoalPostCollision(ball, post) {
                const dx = ball.x - post.x;
                const dy = ball.y - post.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const minDistance = ball.radius + post.radius;
                
                if (distance < minDistance && distance > 0) {
                    // Î§Ï‰ÏÎ¹ÏƒÎ¼ÏŒÏ‚
                    const angle = Math.atan2(dy, dx);
                    const overlap = minDistance - distance;
                    
                    ball.x += Math.cos(angle) * (overlap + 2);
                    ball.y += Math.sin(angle) * (overlap + 2);
                    
                    // Bounce Î¼Îµ restitution
                    const relVelocity = ball.vx * Math.cos(angle) + ball.vy * Math.sin(angle);
                    if (relVelocity < 0) {
                        const restitution = 0.7;  // Î§Î¬Î½ÎµÎ¹ Î»Î¯Î³Î· ÎµÎ½Î­ÏÎ³ÎµÎ¹Î±
                        ball.vx -= (1 + restitution) * relVelocity * Math.cos(angle);
                        ball.vy -= (1 + restitution) * relVelocity * Math.sin(angle);
                    }
                }
            }

            draw() {
                this.drawField();
                
                // Î£Ï‡ÎµÎ´Î¯Î±ÏƒÎ· Ï„Î±Î¼Ï€Î­Î»Î±Ï‚ ÏƒÎºÎ¿Ï Ï€ÏÏÏ„Î± (Ï€Î¯ÏƒÏ‰ Î±Ï€ÏŒ Ï„Î¿ Î³Î®Ï€ÎµÎ´Î¿ Î±Î»Î»Î¬ ÎµÎ¼Ï†Î±Î½Î®Ï‚)
                this.drawScoreboard();
                
                // Î£Ï‡ÎµÎ´Î¯Î±ÏƒÎ· Î³ÏÎ±Î¼Î¼Î®Ï‚ slingshot Î±Î½ Ï„ÏÎ±Î²Î¹Î­Ï„Î±Î¹
                if (this.selectedPlayer && this.dragStart && this.currentDrag) {
                    const dx = this.dragStart.x - this.currentDrag.x;
                    const dy = this.dragStart.y - this.currentDrag.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // ğŸ¯ Î•Î›Î•Î“Î§ÎŸÎ£: Î‘Î½ Î¿ cursor ÎµÎ¯Î½Î±Î¹ Ï€Î¬Î½Ï‰ ÏƒÏ„Î¿Î½ Ï€Î±Î¯ÎºÏ„Î· â†’ ÎœÎ—Î Î´ÎµÎ¯Î¾ÎµÎ¹Ï‚ power meter!
                    const distanceFromPlayer = Math.sqrt(
                        (this.currentDrag.x - this.selectedPlayer.x) ** 2 + 
                        (this.currentDrag.y - this.selectedPlayer.y) ** 2
                    );
                    const playerRadius = this.selectedPlayer.radius;
                    
                    // Î‘Î½ ÎµÎ¯Î½Î±Î¹ Î¼Î­ÏƒÎ± ÏƒÏ„Î¿Î½ ÎºÏÎºÎ»Î¿ (Î¬ÎºÏ…ÏÎ¿ ÏƒÎ¿Ï…Ï„), Î¼Î·Î½ ÏƒÏ‡ÎµÎ´Î¹Î¬ÏƒÎµÎ¹Ï‚ Ï„Î¯Ï€Î¿Ï„Î±
                    if (distanceFromPlayer <= playerRadius * 1.5) {
                        // Î‘ÎšÎ¥Î¡ÎŸ - Î´ÎµÎ½ ÏƒÏ‡ÎµÎ´Î¹Î¬Î¶Î¿Ï…Î¼Îµ power meter
                        // Î”ÎµÎ¯Î¾Îµ Î¼ÏŒÎ½Î¿ Î­Î½Î± hint ÏŒÏ„Î¹ ÎµÎ¯Î½Î±Î¹ cancel zone
                        ctx.beginPath();
                        ctx.arc(this.selectedPlayer.x, this.selectedPlayer.y, playerRadius * 1.5, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(255, 100, 100, 0.4)'; // ÎšÏŒÎºÎºÎ¹Î½Î¿ Î³Î¹Î± cancel zone
                        ctx.lineWidth = 3;
                        ctx.setLineDash([10, 10]);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    } else {
                        // Î•Î“ÎšÎ¥Î¡ÎŸ ÏƒÎ¿Ï…Ï„ - Î´ÎµÎ¯Î¾Îµ Ï„Î¿ power meter ÎºÎ±Î½Î¿Î½Î¹ÎºÎ¬
                        // ÎœÎ­Î³Î¹ÏƒÏ„Î· Î±Ï€ÏŒÏƒÏ„Î±ÏƒÎ· ÎºÎ±Î¹ Ï€ÏÎ±Î³Î¼Î±Ï„Î¹ÎºÎ® Î´ÏÎ½Î±Î¼Î·
                        const maxDragDistance = 200; // Î£Ï…Î½Ï„Î¿Î¼ÏŒÏ„ÎµÏÎ· ÎºÎ»Î¯Î¼Î±ÎºÎ±
                        const actualDistance = Math.min(distance, maxDragDistance);
                        const power = (actualDistance / maxDragDistance) * 100; // 0-100%
                    
                        // Î“ÏÎ±Î¼Î¼Î® ÏƒÏ†ÎµÎ½Ï„ÏŒÎ½Î±Ï‚ - Î Î¹Î¿ Ï€Î±Ï‡Î¹Î¬
                        ctx.beginPath();
                        ctx.moveTo(this.selectedPlayer.x, this.selectedPlayer.y);
                        ctx.lineTo(this.currentDrag.x, this.currentDrag.y);
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                        ctx.lineWidth = 5;
                        ctx.stroke();
                        
                        // Î’Î­Î»Î¿Ï‚ Ï€Î¿Ï… Î´ÎµÎ¯Ï‡Î½ÎµÎ¹ Ï„Î·Î½ ÎºÎ±Ï„ÎµÏÎ¸Ï…Î½ÏƒÎ· ÎµÎºÏ„ÏŒÎ¾ÎµÏ…ÏƒÎ·Ï‚ - Î£Ï…Î½ÎµÏ€Î­Ï‚ Î¼Î®ÎºÎ¿Ï‚
                        const arrowLength = actualDistance * 1.0; // Î¤Î¿ Î²Î­Î»Î¿Ï‚ ÎµÎ¯Î½Î±Î¹ Î±Î½Î¬Î»Î¿Î³Î¿ Ï„Î·Ï‚ Î´ÏÎ½Î±Î¼Î·Ï‚
                        const angle = Math.atan2(-dy, -dx);
                        const arrowX = this.selectedPlayer.x + Math.cos(angle) * arrowLength;
                            const arrowY = this.selectedPlayer.y + Math.sin(angle) * arrowLength;
                        
                        // Î’Î­Î»Î¿Ï‚ Î¼Îµ gradient - Ï‡ÏÏÎ¼Î± Î±Î½Î¬Î»Î¿Î³Î¿ Ï„Î·Ï‚ Î´ÏÎ½Î±Î¼Î·Ï‚
                        const gradient = ctx.createLinearGradient(
                            this.selectedPlayer.x, this.selectedPlayer.y,
                            arrowX, arrowY
                        );
                        
                        if (power < 33) {
                            gradient.addColorStop(0, 'rgba(100, 255, 100, 1)'); // Î ÏÎ¬ÏƒÎ¹Î½Î¿ = Ï‡Î±Î¼Î·Î»Î® Î´ÏÎ½Î±Î¼Î·
                            gradient.addColorStop(1, 'rgba(255, 255, 100, 1)');
                        } else if (power < 66) {
                            gradient.addColorStop(0, 'rgba(255, 255, 100, 1)'); // ÎšÎ¯Ï„ÏÎ¹Î½Î¿ = Î¼ÎµÏƒÎ±Î¯Î± Î´ÏÎ½Î±Î¼Î·
                            gradient.addColorStop(1, 'rgba(255, 200, 0, 1)');
                        } else {
                            gradient.addColorStop(0, 'rgba(255, 200, 0, 1)'); // Î Î¿ÏÏ„Î¿ÎºÎ±Î»Î¯/ÎšÏŒÎºÎºÎ¹Î½Î¿ = Ï…ÏˆÎ·Î»Î® Î´ÏÎ½Î±Î¼Î·
                            gradient.addColorStop(1, 'rgba(255, 100, 0, 1)');
                        }
                        
                        ctx.beginPath();
                        ctx.moveTo(this.selectedPlayer.x, this.selectedPlayer.y);
                        ctx.lineTo(arrowX, arrowY);
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 8;
                        ctx.stroke();
                        
                        // ÎšÎµÏ†Î¬Î»Î¹ Î²Î­Î»Î¿Ï…Ï‚ - ÎœÎµÎ³Î±Î»ÏÏ„ÎµÏÎ¿
                        const arrowHeadSize = 20;
                        ctx.beginPath();
                        ctx.moveTo(arrowX, arrowY);
                        ctx.lineTo(
                            arrowX - arrowHeadSize * Math.cos(angle - Math.PI / 6),
                            arrowY - arrowHeadSize * Math.sin(angle - Math.PI / 6)
                        );
                        ctx.moveTo(arrowX, arrowY);
                        ctx.lineTo(
                            arrowX - arrowHeadSize * Math.cos(angle + Math.PI / 6),
                            arrowY - arrowHeadSize * Math.sin(angle + Math.PI / 6)
                        );
                        ctx.strokeStyle = power > 66 ? 'rgba(255, 100, 0, 1)' : 'rgba(255, 200, 0, 1)';
                        ctx.lineWidth = 8;
                        ctx.stroke();
                        
                        // ï¿½ CURVE ADJUSTMENT MODE VISUAL
                        if (this.selectedPlayer.curveAdjusting) {
                            // Î£Ï‡ÎµÎ´Î¯Î±ÏƒÎµ ÎµÎ¹Î´Î¹ÎºÎ® Î³ÏÎ±Î¼Î¼Î® Î³Î¹Î± curve adjustment
                            ctx.save();
                            
                            // ÎšÏÎºÎ»Î¿Ï‚ Î³ÏÏÏ‰ Î±Ï€ÏŒ Ï€Î±Î¯ÎºÏ„Î· Î³Î¹Î± curve adjustment zone
                            ctx.beginPath();
                            ctx.arc(this.selectedPlayer.x, this.selectedPlayer.y, this.selectedPlayer.radius + 15, 0, Math.PI * 2);
                            ctx.strokeStyle = 'rgba(255, 100, 255, 0.8)'; // Î¡Î¿Î¶/ÎœÏ‰Î² Î³Î¹Î± curve
                            ctx.lineWidth = 4;
                            ctx.setLineDash([5, 5]);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            
                            // Curve direction arrow
                            const curveDx = this.currentDrag.x - this.dragStart.x;
                            const curveDy = this.currentDrag.y - this.dragStart.y;
                            const curveDistance = Math.sqrt(curveDx * curveDx + curveDy * curveDy);
                            
                            if (curveDistance > 10) {
                                const curveAngle = Math.atan2(curveDy, curveDx);
                                const curveArrowLength = Math.min(curveDistance, 150);
                                const curveArrowX = this.selectedPlayer.x + Math.cos(curveAngle) * curveArrowLength;
                                const curveArrowY = this.selectedPlayer.y + Math.sin(curveAngle) * curveArrowLength;
                                
                                // Curve arrow Î¼Îµ gradient
                                const curveGradient = ctx.createLinearGradient(
                                    this.selectedPlayer.x, this.selectedPlayer.y,
                                    curveArrowX, curveArrowY
                                );
                                curveGradient.addColorStop(0, 'rgba(255, 100, 255, 1)');
                                curveGradient.addColorStop(1, 'rgba(200, 50, 255, 1)');
                                
                                ctx.beginPath();
                                ctx.moveTo(this.selectedPlayer.x, this.selectedPlayer.y);
                                ctx.lineTo(curveArrowX, curveArrowY);
                                ctx.strokeStyle = curveGradient;
                                ctx.lineWidth = 6;
                                ctx.stroke();
                                
                                // Arrow head
                                const curveHeadSize = 15;
                                ctx.beginPath();
                                ctx.moveTo(curveArrowX, curveArrowY);
                                ctx.lineTo(
                                    curveArrowX - curveHeadSize * Math.cos(curveAngle - Math.PI / 6),
                                    curveArrowY - curveHeadSize * Math.sin(curveAngle - Math.PI / 6)
                                );
                                ctx.moveTo(curveArrowX, curveArrowY);
                                ctx.lineTo(
                                    curveArrowX - curveHeadSize * Math.cos(curveAngle + Math.PI / 6),
                                    curveArrowY - curveHeadSize * Math.sin(curveAngle + Math.PI / 6)
                                );
                                ctx.strokeStyle = 'rgba(200, 50, 255, 1)';
                                ctx.lineWidth = 6;
                                ctx.stroke();
                                
                                // Text: "Curve Strength"
                                const curveStrength = Math.min(curveDistance / 150, 1.0) * 100;
                                ctx.fillStyle = 'rgba(255, 100, 255, 0.95)';
                                ctx.font = 'bold 24px Arial';
                                ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                                ctx.lineWidth = 3;
                                ctx.strokeText(`ğŸŒ€ Curve: ${curveStrength.toFixed(0)}%`, this.selectedPlayer.x - 60, this.selectedPlayer.y - 50);
                                ctx.fillText(`ğŸŒ€ Curve: ${curveStrength.toFixed(0)}%`, this.selectedPlayer.x - 60, this.selectedPlayer.y - 50);
                            }
                            
                            ctx.restore();
                            
                            // Î”ÎµÎ½ Î´ÎµÎ¯Ï‡Î½Î¿Ï…Î¼Îµ trajectory ÏƒÏ„Î¿ curve adjustment mode
                            return;
                        }
                        
                        // ï¿½ğŸ¯ TRAJECTORY PREDICTION SYSTEM
                        const maxSpeed = 25;
                        
                        // Î£Î©Î£Î¤Î‘ dragX/dragY (ÏŒÏ€Ï‰Ï‚ ÏƒÏ„Î¿ onMouseUp - Î§Î©Î¡Î™Î£ Î±Î½Ï„Î¹ÏƒÏ„ÏÎ¿Ï†Î®!)
                        const dragX = this.currentDrag.x - this.dragStart.x;
                        const dragY = this.currentDrag.y - this.dragStart.y;
                        const dragDistance = Math.sqrt(dragX * dragX + dragY * dragY);
                        const shootPower = Math.min(dragDistance / maxDragDistance, 1.0);
                        
                        // Î¥Ï€Î¿Î»Î¿Î³Î¹ÏƒÎ¼ÏŒÏ‚ Î Î¡Î‘Î“ÎœÎ‘Î¤Î™ÎšÎ—Î£ Ï„Î±Ï‡ÏÏ„Î·Ï„Î±Ï‚ Ï€Î±Î¯ÎºÏ„Î· (ÏŒÏ€Ï‰Ï‚ ÏƒÏ„Î¿ Player.shoot())
                        const dirX = dragDistance > 0 ? dragX / dragDistance : 0;
                        const dirY = dragDistance > 0 ? dragY / dragDistance : 0;
                        const playerVx = -dirX * shootPower * maxSpeed; // ÎœÎ• Î¼ÎµÎ¯Î¿Î½ (slingshot)
                        const playerVy = -dirY * shootPower * maxSpeed; // ÎœÎ• Î¼ÎµÎ¯Î¿Î½ (slingshot)
                        
                        // 1ï¸âƒ£ TRAJECTORY Î¤ÎŸÎ¥ Î Î‘Î™ÎšÎ¤Î— (simulation Ï„Î·Ï‚ ÎºÎ¯Î½Î·ÏƒÎ®Ï‚ Ï„Î¿Ï…)
                        let predPlayerX = this.selectedPlayer.x;
                        let predPlayerY = this.selectedPlayer.y;
                        let predVx = playerVx;
                        let predVy = playerVy;
                        const simulationFriction = playerFriction; // Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ¼Îµ Ï„Î¿ Î Î¡Î‘Î“ÎœÎ‘Î¤Î™ÎšÎŸ friction
                        const playerRadius = this.selectedPlayer.radius;
                        const ballRadius = this.ball.radius;
                        
                        // Î ÏÎ¿ÏƒÎ¿Î¼Î¿Î¯Ï‰ÏƒÎ· ÎºÎ¯Î½Î·ÏƒÎ·Ï‚ Î¼Ï€Î¬Î»Î±Ï‚ (Î±Î½ ÎºÎ¹Î½ÎµÎ¯Ï„Î±Î¹)
                        let predBallX = this.ball.x;
                        let predBallY = this.ball.y;
                        let predBallVx = this.ball.vx;
                        let predBallVy = this.ball.vy;
                        const ballFrictionSim = ballFriction;
                        
                        let hitsBall = false;
                        let hitPoint = null;
                        
                        ctx.strokeStyle = 'rgba(100, 200, 255, 0.9)'; // Î Î¹Î¿ Ï†Ï‰Ï„ÎµÎ¹Î½ÏŒ Î³Î±Î»Î¬Î¶Î¹Î¿
                        ctx.lineWidth = 4; // Î Î¹Î¿ Ï€Î±Ï‡Ï
                        ctx.setLineDash([10, 10]); // Î Î¹Î¿ Î¼ÎµÎ³Î¬Î»Î± dots
                        ctx.beginPath();
                        ctx.moveTo(predPlayerX, predPlayerY);
                        
                        // Simulate player movement
                        for (let i = 0; i < 50; i++) { // Î ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎ± steps
                            // ÎšÎ¯Î½Î·ÏƒÎ· Ï€Î±Î¯ÎºÏ„Î·
                            predPlayerX += predVx;
                            predPlayerY += predVy;
                            predVx *= simulationFriction;
                            predVy *= simulationFriction;
                            
                            // ÎšÎ¯Î½Î·ÏƒÎ· Î¼Ï€Î¬Î»Î±Ï‚ (Î±Î½ ÎºÎ¹Î½ÎµÎ¯Ï„Î±Î¹)
                            predBallX += predBallVx;
                            predBallY += predBallVy;
                            predBallVx *= ballFrictionSim;
                            predBallVy *= ballFrictionSim;
                            if (Math.abs(predBallVx) < 0.1) predBallVx = 0;
                            if (Math.abs(predBallVy) < 0.1) predBallVy = 0;
                            
                            // Check collision Î¼Îµ Î¼Ï€Î¬Î»Î± (Î¯Î´Î¹Î± Î±ÎºÏÎ¹Î²ÏÏ‚ Î»Î¿Î³Î¹ÎºÎ® Î¼Îµ Player.checkCollision)
                            const distToBall = Math.sqrt(
                                (predPlayerX - predBallX) ** 2 + 
                                (predPlayerY - predBallY) ** 2
                            );
                            const minDistance = playerRadius + ballRadius;
                            
                            if (distToBall < minDistance && !hitsBall) {
                                hitsBall = true;
                                hitPoint = { x: predPlayerX, y: predPlayerY, vx: predVx, vy: predVy, ballX: predBallX, ballY: predBallY };
                                break; // Stop player trajectory ÏƒÏ„Î¿ ÏƒÎ·Î¼ÎµÎ¯Î¿ ÏƒÏÎ³ÎºÏÎ¿Ï…ÏƒÎ·Ï‚
                            }
                            
                            // Stop Î±Î½ Ï€Î¿Î»Ï Î±ÏÎ³Î¬
                            if (Math.abs(predVx) < 0.3 && Math.abs(predVy) < 0.3) break;
                            
                            // Boundary
                            if (predPlayerX < 50 || predPlayerX > 1550 || predPlayerY < 50 || predPlayerY > 850) break;
                            
                            ctx.lineTo(predPlayerX, predPlayerY);
                        }
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // 2ï¸âƒ£ TRAJECTORY Î¤Î—Î£ ÎœÎ Î‘Î›Î‘Î£ (Î¼ÏŒÎ½Î¿ Î±Î½ Ï‡Ï„Ï…Ï€Î¬ÎµÎ¹)
                        if (hitsBall && hitPoint) {
                            // Î¥Ï€Î¿Î»Î¿Î³Î¹ÏƒÎ¼ÏŒÏ‚ Î¼ÎµÏ„Î±Ï†Î¿ÏÎ¬Ï‚ Î¿ÏÎ¼Î®Ï‚ Î±Ï€ÏŒ Ï€Î±Î¯ÎºÏ„Î· ÏƒÎµ Î¼Ï€Î¬Î»Î± (Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÏÎ½Ï„Î±Ï‚ Ï„Î· Î½Î­Î± Î¸Î­ÏƒÎ· Î¼Ï€Î¬Î»Î±Ï‚)
                            const angle = Math.atan2(
                                hitPoint.ballY - hitPoint.y,
                                hitPoint.ballX - hitPoint.x
                            );
                            
                            // ÎœÎµÏ„Î±Ï†Î¿ÏÎ¬ Î¿ÏÎ¼Î®Ï‚ Î¼Îµ restitution & mass ratio
                            const restitution = 0.9;
                            const massRatio = 0.8;
                            const relVelocityDotNormal = hitPoint.vx * Math.cos(angle) + hitPoint.vy * Math.sin(angle);
                            const impulse = (1 + restitution) * relVelocityDotNormal * massRatio;
                            
                            // Î— Î¼Ï€Î¬Î»Î± Ï€Î±Î¯ÏÎ½ÎµÎ¹ Ï„Î±Ï‡ÏÏ„Î·Ï„Î± Î±Ï€ÏŒ Ï„Î· ÏƒÏÎ³ÎºÏÎ¿Ï…ÏƒÎ·
                            let ballVx = Math.cos(angle) * impulse;
                            let ballVy = Math.sin(angle) * impulse;
                            let ballX = hitPoint.ballX;  // Î‘ÏÏ‡Î¯Î¶ÎµÎ¹ Î±Ï€ÏŒ Ï„Î· Î½Î­Î± Î¸Î­ÏƒÎ· Ï„Î·Ï‚ Î¼Ï€Î¬Î»Î±Ï‚
                            let ballY = hitPoint.ballY;
                            const ballFriction = 0.97;
                            
                            // Î¥Ï€Î¿Î»Î¿Î³Î¹ÏƒÎ¼ÏŒÏ‚ Î±Ï€ÏŒÏƒÏ„Î±ÏƒÎ·Ï‚ Î±Ï€ÏŒ Ï„Î­ÏÎ¼Î± Î±Î½Ï„Î¹Ï€Î¬Î»Î¿Ï… Î³Î¹Î± Ï€ÏÎ¿ÏƒÎ±ÏÎ¼Î¿Î³Î® Î¼Î®ÎºÎ¿Ï…Ï‚ trajectory
                            // Î‘ÏÎ¹ÏƒÏ„ÎµÏÏŒ Ï„Î­ÏÎ¼Î±: x = 0-50, Î”ÎµÎ¾Î¯ Ï„Î­ÏÎ¼Î±: x = 1550-1600
                            const isRedTeam = this.selectedPlayer.color === '#ff3420'; // ÎšÏŒÎºÎºÎ¹Î½Î· Î¿Î¼Î¬Î´Î± (Î±ÏÎ¹ÏƒÏ„ÎµÏÎ¬)
                            const opponentGoalX = isRedTeam ? 1600 : 0; // Î¤Î­ÏÎ¼Î± Î±Î½Ï„Î¹Ï€Î¬Î»Î¿Ï…
                            const distanceToGoal = Math.abs(hitPoint.ballX - opponentGoalX);
                            
                            // Î§Ï‰ÏÎ¯Î¶Î¿Ï…Î¼Îµ Ï„Î¿ Î³Î®Ï€ÎµÎ´Î¿ ÏƒÎµ Î¶ÏÎ½ÎµÏ‚:
                            // ÎšÎ¿Î½Ï„Î¬ ÏƒÏ„Î¿ Ï„Î­ÏÎ¼Î± (0-400px): 5-8 steps
                            // ÎœÎ­ÏƒÎ· Î±Ï€ÏŒÏƒÏ„Î±ÏƒÎ· (400-800px): 8-15 steps
                            // ÎœÎ±ÎºÏÎ¹Î¬ (800-1600px): 15-25 steps
                            let maxSteps;
                            if (distanceToGoal < 400) {
                                maxSteps = Math.floor(5 + (distanceToGoal / 400) * 3); // 5-8
                            } else if (distanceToGoal < 800) {
                                maxSteps = Math.floor(8 + ((distanceToGoal - 400) / 400) * 7); // 8-15
                            } else {
                                maxSteps = Math.floor(15 + ((distanceToGoal - 800) / 800) * 10); // 15-25
                            }
                            
                            ctx.strokeStyle = 'rgba(255, 255, 100, 1.0)'; // Î Î¿Î»Ï Ï†Ï‰Ï„ÎµÎ¹Î½ÏŒ ÎºÎ¯Ï„ÏÎ¹Î½Î¿
                            ctx.lineWidth = 5; // Î Î¿Î»Ï Ï€Î±Ï‡Ï
                            ctx.setLineDash([10, 10]);
                            ctx.beginPath();
                            ctx.moveTo(ballX, ballY);
                            
                            // Î ÏÎ¿ÏƒÎ±ÏÎ¼Î¿ÏƒÎ¼Î­Î½Î¿ Î¼Î®ÎºÎ¿Ï‚ trajectory Î±Î½Î¬Î»Î¿Î³Î± Î¼Îµ Î±Ï€ÏŒÏƒÏ„Î±ÏƒÎ· Î±Ï€ÏŒ Ï„Î­ÏÎ¼Î±
                            for (let i = 0; i < maxSteps; i++) {
                                ballX += ballVx;
                                ballY += ballVy;
                                ballVx *= ballFriction;
                                ballVy *= ballFriction;
                                
                                if (Math.abs(ballVx) < 0.3 && Math.abs(ballVy) < 0.3) break;
                                if (ballX < 50 || ballX > 1550 || ballY < 50 || ballY > 850) break;
                                
                                ctx.lineTo(ballX, ballY);
                            }
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }
                        
                        // Î”ÎµÎ¯ÎºÏ„Î·Ï‚ Î´ÏÎ½Î±Î¼Î·Ï‚ - Î‘ÎšÎ¡Î™Î’Î—Î£ Ï€Î¿ÏƒÎ¿ÏƒÏ„ÏŒ
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                        ctx.font = 'bold 32px Arial';
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                        ctx.lineWidth = 3;
                        const powerText = `${Math.floor(power)}%`;
                        ctx.strokeText(powerText, this.currentDrag.x + 30, this.currentDrag.y - 30);
                        ctx.fillText(powerText, this.currentDrag.x + 30, this.currentDrag.y - 30);
                        
                        // Î ÏÎ¿ÎµÎ¹Î´Î¿Ï€Î¿Î¯Î·ÏƒÎ· Î±Î½ Î­Ï†Ï„Î±ÏƒÎµÏ‚ Ï„Î¿ Î¼Î­Î³Î¹ÏƒÏ„Î¿
                        if (distance >= maxDragDistance) {
                            ctx.fillStyle = 'rgba(255, 50, 50, 0.95)';
                            ctx.font = 'bold 24px Arial';
                            ctx.strokeText('MAX!', this.currentDrag.x + 30, this.currentDrag.y - 65);
                            ctx.fillText('MAX!', this.currentDrag.x + 30, this.currentDrag.y - 65);
                        }
                    } // ÎšÎ»ÎµÎ¯ÏƒÎ¹Î¼Î¿ Ï„Î¿Ï… else block
                }
                
                this.botTeam.forEach(p => p.draw());
                this.playerTeam.forEach(p => p.draw());
                
                this.ball.draw();
                
                // Î”ÎŸÎšÎ‘Î¡Î™Î‘ - Î¤Î•Î›Î•Î¥Î¤Î‘Î™Î‘ Î Î¡Î‘Î“ÎœÎ‘Î¤Î‘ Î ÎŸÎ¥ Î£Î§Î•Î”Î™Î‘Î–ÎŸÎÎ¤Î‘Î™ (Ï€Î¬Î½Ï‰ Î±Ï€ÏŒ ÎŸÎ›Î‘)
                const sideMargin2 = 240;
                const topMargin2 = 180;
                const bottomMargin2 = 80;
                const centerY2 = (topMargin2 + (canvas.height - bottomMargin2)) / 2;
                
                // Î‘ÏÎ¹ÏƒÏ„ÎµÏÎ¬ (ÎœÎ Î›Î•)
                this.drawGoalPost(sideMargin2, centerY2 - 90, 8, '#2745e1');
                this.drawGoalPost(sideMargin2, centerY2 + 90, 8, '#2745e1');
                // Î”ÎµÎ¾Î¹Î¬ (ÎšÎŸÎšÎšÎ™ÎÎ‘)
                this.drawGoalPost(canvas.width - sideMargin2, centerY2 - 90, 8, '#ff3420');
                this.drawGoalPost(canvas.width - sideMargin2, centerY2 + 90, 8, '#ff3420');
                
                // Î•Î¼Ï†Î¬Î½Î¹ÏƒÎ· Î¼Î·Î½ÏÎ¼Î±Ï„Î¿Ï‚ Î³ÎºÎ¿Î» Î® Ï†Î¬Î¿Ï…Î»
                if (this.goalMessage) {
                    // Î£ÎºÎ¿Ï„ÎµÎ¹Î½ÏŒ overlay
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const lines = this.goalMessage.split('\n');
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ Î±Î½ ÎµÎ¯Î½Î±Î¹ Î¦Î‘ÎŸÎ¥Î› Î® Î“ÎšÎŸÎ›
                    const isFoul = lines[0] === 'Î¦Î‘ÎŸÎ¥Î›!';
                    
                    // Î ÏÏÏ„Î· Î³ÏÎ±Î¼Î¼Î® - Î“ÎšÎŸÎ› Î® Î¦Î‘ÎŸÎ¥Î›
                    ctx.font = 'bold 120px Arial';
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.lineWidth = 8;
                    ctx.strokeText(lines[0], canvas.width / 2, canvas.height / 2 - 60);
                    
                    if (isFoul) {
                        // Î¦Î‘ÎŸÎ¥Î› - ÎšÏŒÎºÎºÎ¹Î½Î¿ gradient
                        const foulGradient = ctx.createLinearGradient(0, canvas.height / 2 - 120, 0, canvas.height / 2);
                        foulGradient.addColorStop(0, '#FF0000');
                        foulGradient.addColorStop(1, '#CC0000');
                        ctx.fillStyle = foulGradient;
                        ctx.fillText(lines[0], canvas.width / 2, canvas.height / 2 - 60);
                    } else {
                        // Î“ÎšÎŸÎ› - Î§ÏÏ…ÏƒÏŒ gradient
                        const goalGradient = ctx.createLinearGradient(0, canvas.height / 2 - 120, 0, canvas.height / 2);
                        goalGradient.addColorStop(0, '#FFD700');
                        goalGradient.addColorStop(1, '#FFA500');
                        ctx.fillStyle = goalGradient;
                        ctx.fillText(lines[0], canvas.width / 2, canvas.height / 2 - 60);
                    }
                    
                    // Î¥Ï€ÏŒÎ»Î¿Î¹Ï€ÎµÏ‚ Î³ÏÎ±Î¼Î¼Î­Ï‚
                    for (let i = 1; i < lines.length; i++) {
                        const yOffset = 60 + ((i - 1) * 55);
                        ctx.font = i === 1 ? 'bold 48px Arial' : 'bold 38px Arial';
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                        ctx.lineWidth = 5;
                        ctx.strokeText(lines[i], canvas.width / 2, canvas.height / 2 + yOffset);
                        ctx.fillStyle = isFoul ? '#FFB0B0' : '#FFFFFF';
                        ctx.fillText(lines[i], canvas.width / 2, canvas.height / 2 + yOffset);
                    }
                    
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'alphabetic';
                }
            }

            loop() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.loop());
            }
        }

        // roundRect polyfill
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
                this.beginPath();
                this.moveTo(x + r, y);
                this.lineTo(x + w - r, y);
                this.quadraticCurveTo(x + w, y, x + w, y + r);
                this.lineTo(x + w, y + h - r);
                this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                this.lineTo(x + r, y + h);
                this.quadraticCurveTo(x, y + h, x, y + h - r);
                this.lineTo(x, y + r);
                this.quadraticCurveTo(x, y, x + r, y);
                this.closePath();
                return this;
            };
        }

        // Î£Ï…Î½Î¬ÏÏ„Î·ÏƒÎ· Ï€Î¿Ï… Î¾ÎµÎºÎ¹Î½Î¬ÎµÎ¹ Ï„Î¿ Ï€Î±Î¹Ï‡Î½Î¯Î´Î¹
        // Global game variable for multiplayer sync
        let game = null;

        function startGame() {
            console.log('Starting game...');
            game = new Game();
            game.loop();
        }
        
        // ğŸ¦† Create floating ducks in background
        function createFloatingDucks() {
            const container = document.getElementById('floatingDucks');
            const duckCount = 15; // Î‘ÏÎ¹Î¸Î¼ÏŒÏ‚ Ï€Î±Ï€Î¹ÏÎ½
            
            for (let i = 0; i < duckCount; i++) {
                const duck = document.createElement('img');
                duck.src = './Assets/duck.png';
                duck.className = 'floating-duck';
                
                // Î¤Ï…Ï‡Î±Î¯Î± Î¸Î­ÏƒÎ·
                duck.style.left = Math.random() * 100 + '%';
                duck.style.top = Math.random() * 100 + '%';
                
                // Î¤Ï…Ï‡Î±Î¯Î± rotation
                duck.style.transform = `rotate(${Math.random() * 360}deg)`;
                
                // Î¤Ï…Ï‡Î±Î¯Î± Î´Î¹Î¬ÏÎºÎµÎ¹Î± animation
                duck.style.animationDuration = (15 + Math.random() * 15) + 's';
                
                // Î¤Ï…Ï‡Î±Î¯Î± ÎºÎ±Î¸Ï…ÏƒÏ„Î­ÏÎ·ÏƒÎ·
                duck.style.animationDelay = (Math.random() * 5) + 's';
                
                container.appendChild(duck);
            }
        }
        
        // Create ducks when page loads
        createFloatingDucks();
        
        // Î”Î•Î Î¾ÎµÎºÎ¹Î½Î¬Î¼Îµ Î±Ï€ÎµÏ…Î¸ÎµÎ¯Î±Ï‚ - Î ÎµÏÎ¹Î¼Î­Î½Î¿Ï…Î¼Îµ Ï„Î¹Ï‚ ÎµÎ¹ÎºÏŒÎ½ÎµÏ‚!
    </script>
</body>
</html>
